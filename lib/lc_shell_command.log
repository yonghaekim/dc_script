#@ # 
#@ # Running lc_shell Version T-2022.03-SP1 for linux64 -- Apr 12, 2022
#@ # Date:   Fri Jul 29 18:30:37 2022
#@ # Run by: ykim816@gtcad-srv3.ece.gatech.edu
#@ 

source /tools/software/synopsys/lc/latest/admin/setup//.synopsys_lc.setup
#@ # -- Starting source /tools/software/synopsys/lc/latest/admin/setup//.synopsys_lc.setup

#@ #
#@ #
#@ #		".synopsys_lc.setup" Initialization File for
#@ #
#@ #		    Lc_Shell and Library_compiler
#@ #
#@ #	The variables in this file define the behavior of many parts
#@ #	of the Synopsys Synthesis Tools.  Upon installation, they should 
#@ #	be reviewed and modified to fit your site's needs.  Each engineer
#@ #	can have a .synopsys file in his/her home directory or current
#@ #	directory to override variable settings in this file.  
#@ #
#@ 
#@ # System variables
#@ # system default value for sh_continue_on_error is "false"
#@ set sh_continue_on_error         "true"
#@ # system default value for sh_source_uses_search_path is "false"
#@ set sh_source_uses_search_path   "true"
#@ 
#@ # Enable customer support banner on fatal
#@ if { $sh_arch == "linux"    || $sh_arch == "amd64"    || $sh_arch == "linux64" || \
#@      $sh_arch == "sparcOS5" || $sh_arch == "sparc64"  || \
#@      $sh_arch == "x86sol32" || $sh_arch == "x86sol64" || \
#@      $sh_arch == "rs6000"   || $sh_arch == "aix64" } {
#@    setenv SYNOPSYS_TRACE ""
#@ }
#@ 
#@ #
#@ # Load the procedures which make up part of the user interface.
#@ #
#@ source $synopsys_root/auxx/syn/.lc_procs.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/syn/.lc_procs.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         auxx/syn/.lc_procs.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ #
#@ #
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:  add_model
#@ #
#@ #  ABSTRACT:  dummy call
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc add_model { args } {
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   remove_design
#@ #
#@ #  ABSTRACT:    map remove_design to remove_lib
#@ #
#@ #  HISTORY :    2014/05/09, Synopsys, initial
#@ #
#@ ##############################################################################
#@ 
#@ proc remove_design { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   if {[info exists ra(-library)]} {
#@     set cmd [format {remove_lib %s} $ra(-library)]
#@   } elseif {[info exists ra(-all)]} {
#@     set cmd {remove_lib -all}
#@   } else {
#@     set cmd [format {remove_lib [list %s]} $args]
#@   }
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes remove_design -hide_body \
#@     -info " alias of remove_lib " \
#@     -define_args {\
#@       {file_names "" file_names list {optional hidden}}\
#@     }
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/syn/.lc_procs.tcl

#@ source $synopsys_root/auxx/lc/.lc_scripts.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/.lc_scripts.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         lc_scripts.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ 
#@ ##############################################################################
#@ # Proc: read in the csv file to list of list
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # -channel: the input csv file
#@ # -header: == 1: use first line as index; header == 0: use row number as index
#@ # -symbol: delimiter, default is ","
#@ ##############################################################################
#@ proc read_csv { channel { header 1 } { symbol , }} {
#@ 	set quote 0	
#@ 	set data [ split [ read $channel nonewline ] "\n" ]
#@ 	foreach line $data {
#@ 		set quote [ expr { $quote + [ regexp -all \" $line ]}]
#@ 		if { [ expr { $quote % 2 }] == "0" } {
#@ 			set quote 0
#@ 			append row_temp $line
#@ 			set row_temp [ split $row_temp , ]	
#@ 			foreach section $row_temp {
#@ 				set quote [ expr { $quote + [ regexp -all \" $section ]}]
#@ 				if { [ expr { $quote % 2 }] == "0" } {
#@ 					append cell_temp $section
#@ 					set cell_temp [ regsub {^\s*(.*\S)\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {^\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {"(.*)"} $cell_temp {\1} ]
#@ 					lappend cell $cell_temp
#@ 					unset cell_temp
#@ 					set quote 0
#@ 				} else {
#@ 					append cell_temp $section$symbol
#@ 				}
#@ 			}
#@ 			lappend final [ regsub -all {""} $cell \" ]
#@ 			unset cell
#@ 			unset row_temp
#@ 		} else {
#@ 			append row_temp $line\n
#@ 		}
#@ 	}
#@ 	# return list of list
#@ 	return $final
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes read_csv -hidden
#@ 
#@ ##############################################################################
#@ # Proc: sort the db_filename
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # Return array: key is db name, value is a list of colomn number
#@ ##############################################################################
#@ proc sort_array_by_db_filename { final id } {
#@ 	set row [ llength $final ]
#@ 
#@ 	for { set i 1 } { $i < $row } { incr i } {
#@ 		set db_name [lindex [lindex $final $i] $id]
#@     set db_ids [array names db_map $db_name]
#@     if { [string length $db_ids] > 0} {
#@       set db_map($db_name) [concat $db_map($db_name) $i]
#@     } else {
#@       set db_map($db_name) $i
#@     }
#@   }
#@ 
#@   return [ array get db_map ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes sort_array_by_db_filename -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get nldm delay point index/value
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # Args: -matching_point: 1: fit; others: bucket;
#@ # Return: for fit mode, return 1 grid point
#@ #   for bucket mode, return a list of grid points
#@ #
#@ # Support NLDM NLPM query
#@ #
#@ # For different dimension lookup table
#@ #         fit                     bucket
#@ #   2-D:  1 (idx1,idx2,val)       4 * 3 (idx1,idx2,val)
#@ #   1-D:  1 (idx1,val)            2 * 2 (idx1,val)
#@ #   0-D:  1 (val)                 1 (val)
#@ #
#@ # The return array always contain 3 items (fit mode) or 12 items (bucket mode)
#@ # The unused ones are left empty for 1-D/0-D lookup table
#@ # If find any error, return array contains same number itmes with empty value
#@ ##############################################################################
#@ proc get_nldm_delay_point { line header idx {matching_point 1} } {
#@ 
#@   set column [llength $header]
#@ 	for { set j 0 } { $j < $column } { incr j } {
#@ 		set rec([ lindex $header $j ],$idx) [ lindex $line $j ]
#@   }
#@ 
#@   # initial return array
#@   if { $matching_point ==1 } {
#@     set tb(idx1,$idx) ""
#@     set tb(idx2,$idx) ""
#@     set tb(value,$idx) ""
#@   } else {
#@     set tb(idx1_a,$idx) ""
#@     set tb(idx2_a,$idx) ""
#@     set tb(value_a,$idx) ""
#@     set tb(idx1_b,$idx) ""
#@     set tb(idx2_b,$idx) ""
#@     set tb(value_b,$idx) ""
#@     set tb(idx1_c,$idx) ""
#@     set tb(idx2_c,$idx) ""
#@     set tb(value_c,$idx) ""
#@     set tb(idx1_d,$idx) ""
#@     set tb(idx2_d,$idx) ""
#@     set tb(value_d,$idx) ""
#@   }
#@ 
#@   # check library
#@   if { [string length [array names rec library,$idx]] ==0 ||
#@     [string length $rec(library,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'library' for query."
#@     return [ array get tb ]
#@   }
#@   # check cell 
#@   if { [string length [array names rec cell,$idx]] ==0 ||
#@     [string length $rec(cell,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'cell' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get the cell, save the collection into global array for fast access next time.
#@   global lc_cells
#@   set lib_cell_name [array names lc_cells $rec(library,$idx)/$rec(cell,$idx)]
#@   if { [string length $lib_cell_name] > 0} {
#@     set pcell $lc_cells($lib_cell_name)
#@   } else {
#@     set pcell [get_lib_cells $rec(library,$idx)/$rec(cell,$idx)]
#@     if { [sizeof_collection $pcell] == 1 } {
#@       set lc_cells($rec(library,$idx)/$rec(cell,$idx)) $pcell
#@     } else {
#@       echo "line [expr $idx+1]: Error! Can't find this cell group."
#@       return [array get tb ]
#@     }
#@   }
#@ 
#@   # check group
#@   if { [string length [array names rec group,$idx]] ==0 ||
#@     [string length $rec(group,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'group' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value NOT from lookup table
#@   if { [string equal $rec(group,$idx) leakage_power] } {
#@     # leakage power
#@  
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # set options: of_object, class_type, filter
#@     lappend opts -of_objects $pcell -class_type leakage_power
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@ 
#@     # get leakage power 
#@     set arc [eval get_lib_objects $opts]
#@     
#@     if {[sizeof_collection $arc] == 0} {
#@       echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@       return [array get tb ]
#@     } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@       echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@       set arc [index_collection $arc 0]
#@     }
#@ 
#@     set value [format %g [get_lib_attribute $arc value]]
#@ 
#@     if { $matching_point ==1 } {
#@       if {[info exists value]} {
#@         set tb(value,$idx) $value
#@       }
#@     } else {
#@       if {[info exists value]} {
#@         set tb(value_a,$idx) $value
#@       }
#@     }
#@ 
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value from lookup table
#@   if { [string equal $rec(group,$idx) cell_rise] ||
#@     [string equal $rec(group,$idx) cell_fall] ||
#@     [string equal $rec(group,$idx) rise_constraint] ||
#@     [string equal $rec(group,$idx) fall_constraint] ||
#@     [string equal $rec(group,$idx) rise_propagation] ||
#@     [string equal $rec(group,$idx) fall_propagation] ||
#@     [string equal $rec(group,$idx) rise_transition] ||
#@     [string equal $rec(group,$idx) fall_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_rise] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_fall] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_transition] } {
#@     # NLDM timing
#@ 
#@     # set filter
#@     if { [string length [array names rec timing_type,$idx]] >0 &&
#@       [string length $rec(timing_type,$idx)] >0 } {
#@       set ft \(timing_type==$rec(timing_type,$idx)\)
#@     }
#@     if { [string length [array names rec timing_sense,$idx]] >0 &&
#@       [string length $rec(timing_sense,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(timing_sense==$rec(timing_sense,$idx)\)
#@       } else {
#@         set ft \(timing_sense==$rec(timing_sense,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(when==\"$rec(when_cond,$idx)\"\)
#@       } else {
#@         set ft \(when==\"$rec(when_cond,$idx)\"\)
#@       }
#@     }
#@ 
#@     # set options: of_object, from pin, to pin, filter
#@     lappend opts -of_objects $pcell
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       lappend opts -to $rec(pin,$idx)
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       lappend opts -from $rec(related_pin,$idx)
#@     }
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@   
#@     # get timing arc
#@     set arc [eval get_lib_timing_arcs $opts]
#@ 
#@   } elseif { [string equal $rec(group,$idx) rise_power] ||
#@     [string equal $rec(group,$idx) fall_power] } {
#@     # NLPM internal power
#@ 
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pin==$rec(related_pin,$idx)\)
#@       } else {
#@         set ft \(related_pin==$rec(related_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # get pin
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       set pin [get_lib_objects -of_objects $pcell -class_type pin -filter name==$rec(pin,$idx)]
#@       if {[sizeof_collection $pin] != 1} {
#@         echo "line [expr $idx+1]: Error! Can't find this pin group."
#@         return [array get tb ]
#@       }
#@ 
#@       # set options: of_object, -class_type, filter
#@       lappend opts -of_objects $pin -class_type internal_power
#@       if {[info exists ft]} {
#@         lappend opts -filter $ft
#@       }
#@       
#@       # get internal power 
#@       set arc [eval get_lib_objects $opts]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $arc] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@     set arc [index_collection $arc 0]
#@   }
#@ 
#@   # get the lookup table
#@   set lt [get_lookup_table -of_object $arc $rec(group,$idx)]
#@ 
#@   if {[sizeof_collection $lt] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this lookup table."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $lt] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple lookup table, use the first one!"
#@     set lt [index_collection $lt 0]
#@   }
#@ 
#@   # won't consider index pairing for now
#@   # input_slew == input_net_transition/input_transition_time
#@   # output_load == total_output_net_capacitance
#@   set index1 input_net_transition
#@   set index2 total_output_net_capacitance
#@ 
#@   set ids [lookup_table variables $lt]
#@   
#@   if { [llength $ids] == 1} {
#@     set index1 [lindex $ids 0]
#@   } elseif { [llength $ids] == 2} {
#@     set index1 [lindex $ids 0]
#@     set index2 [lindex $ids 1]
#@   }
#@     
#@   # constraint template could have issue here
#@   # constraint variable related_pin_transition/constrained_pin_transition
#@   # doesn't follow the input csv table index name input_slew/output_load
#@   # then we don't know how to pair them
#@   if { $index1=="total_output_net_capacitance" } {
#@     set tmp_index $index1
#@     set index1 $index2
#@     set index2 $tmp_index
#@   }
#@ 
#@   if { [string length [array names rec input_slew,$idx]] >0 &&
#@     [string length $rec(input_slew,$idx)] >0 } {
#@     lappend pointl $index1 $rec(input_slew,$idx)
#@   }
#@   if { [string length [array names rec output_load,$idx]] >0 &&
#@     [string length $rec(output_load,$idx)] >0 } {
#@     lappend pointl $index2 $rec(output_load,$idx)
#@   }
#@ 
#@   # lookup_table fit/bucket …
#@   if { $matching_point ==1 } {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 3} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(idx2,$idx) [format %g [lindex $m_list 1] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   } else {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 4} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(idx2_a,$idx) [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 2] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(idx2_b,$idx) [format %g [lindex [lindex $m_list 1] 1] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 2] ]
#@         set tb(idx1_c,$idx) [format %g [lindex [lindex $m_list 2] 0] ]
#@         set tb(idx2_c,$idx) [format %g [lindex [lindex $m_list 2] 1] ]
#@         set tb(value_c,$idx)  [format %g [lindex [lindex $m_list 2] 2] ]
#@         set tb(idx1_d,$idx) [format %g [lindex [lindex $m_list 3] 0] ]
#@         set tb(idx2_d,$idx) [format %g [lindex [lindex $m_list 3] 1] ]
#@         set tb(value_d,$idx)  [format %g [lindex [lindex $m_list 3] 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value_a,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   }
#@   if {[string match {[a-zA-Z]*} $msg]} {
#@     echo Line [expr $idx+1]: Error! [string trim $msg \n]
#@   }
#@ 
#@   return [ array get tb ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes get_nldm_delay_point -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_lib_grid_points
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # -matching_point: 1 fit; 2 bucket
#@ # -input_csv_file: the input csv file contains the querry condition
#@ # -output_csv_file: the input csv file contains the querry condition and query result
#@ #
#@ # Modified: Synopsys 2015/12/10
#@ #   change proc name from "check_qualified_data_point" to "get_lib_lookup_data"
#@ # Modified: Synopsys 2016/01/05
#@ #   change proc name from "get_lib_lookup_data" to "get_lib_grid_points"
#@ ##############################################################################
#@ proc get_lib_grid_points {args} {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set input_csv_file $ra(input_csv_file)
#@   set output_csv_file $ra(output_csv_file)
#@ 
#@   if { [string length [array names ra matching_point]] ==0 } {
#@     set matching_point 1
#@   } else {
#@     set matching_point $ra(matching_point)
#@   }
#@ 
#@   # get the input csv data, put in 2-D table (list of list)
#@   set in [open $input_csv_file r]
#@   set table [ read_csv $in ]
#@   close $in
#@ 	
#@   # get row/column/header
#@   set row [ llength $table ]
#@   set header [ lindex $table 0 ]
#@   set column [ llength $header ]
#@ 
#@   # check each header index name is correct
#@   set all_header {db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load}
#@   foreach item $header {
#@     if {[lsearch -exact $all_header $item] <0 } {
#@       echo "Error: Can't use '$item' as index."
#@       echo "The allowed index names are 'db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load'."
#@       return;
#@     }
#@   }
#@   
#@   # db_id is the colomn for "db_filename"
#@   set db_id [lsearch -exact $header db_filename]
#@   if { $db_id <0 } {
#@     echo "Error: User must specify 'db_filename' index in the input_csv_file."
#@     return
#@   }
#@   set lib_id [lsearch -exact $header library]
#@   if { $lib_id <0 } {
#@     echo "Error: User must specify 'library' index in the input_csv_file."
#@     return
#@   }
#@   
#@   # db_map is the mapping from db_filename to "row number" list
#@   array set db_map [sort_array_by_db_filename $table $db_id]
#@   set db_names [array names db_map]
#@   global lc_cells
#@   
#@   # set process meter
#@   incr row -1
#@   set count 1
#@   if { $row > 10000 } {
#@     set pct_instance [expr $row/100]
#@   } else {
#@     set pct_instance 100
#@   }
#@   
#@   # check each db at a time for saving memory
#@   foreach db $db_names {
#@     redirect -variable msg {echo [read_db $db]}
#@     set idx_list $db_map($db)
#@     array set lc_cells {0 0}
#@     foreach idx $idx_list {
#@ 
#@       # echo process meter
#@       if { $count % $pct_instance == 0 } {
#@         echo "Processing Cell Instance $count : out of $row"
#@         #echo [eval date]
#@       }
#@ 
#@       # get the querry data
#@       set line [lindex $table $idx]
#@       array set result [get_nldm_delay_point $line $header $idx $matching_point]
#@       
#@       # save the querry result
#@       if { $matching_point ==1 } {
#@         lappend line $result(idx1,$idx)
#@         lappend line $result(idx2,$idx)
#@         lappend line $result(value,$idx)
#@       } else {
#@         lappend line $result(idx1_a,$idx)
#@         lappend line $result(idx2_a,$idx)
#@         lappend line $result(value_a,$idx)
#@         lappend line $result(idx1_b,$idx)
#@         lappend line $result(idx2_b,$idx)
#@         lappend line $result(value_b,$idx)
#@         lappend line $result(idx1_c,$idx)
#@         lappend line $result(idx2_c,$idx)
#@         lappend line $result(value_c,$idx)
#@         lappend line $result(idx1_d,$idx)
#@         lappend line $result(idx2_d,$idx)
#@         lappend line $result(value_d,$idx)
#@       }
#@       set table [lreplace $table $idx $idx $line]
#@       
#@       incr count
#@     }
#@     unset lc_cells
#@ 		set lib_name [lindex [lindex $table $idx] $lib_id]
#@     redirect -variable msg {echo [remove_lib $db:$lib_name]}
#@ 
#@   }
#@ 
#@   # write to output csv file
#@   set out [open $output_csv_file w+]
#@ 
#@   if { $matching_point ==1 } {
#@     lappend header idx1 idx2 value
#@   } else {
#@     lappend header idx1_a idx2_a value_a idx1_b idx2_b value_b idx1_c idx2_c value_c idx1_d idx2_d value_d
#@   }
#@   set table [lreplace $table 0 0 $header]
#@   set row [ llength $table ]
#@   set column [ llength $header ]
#@ 
#@   set symbol ,
#@   for { set i 0 } { $i < $row } { incr i } {		
#@     puts -nonewline $out [lindex [lindex $table $i] 0]
#@ 	  for { set j 1 } { $j < $column } { incr j } {
#@       puts -nonewline $out $symbol
#@       puts -nonewline $out [lindex [lindex $table $i] $j]
#@ 		}
#@     puts $out ""
#@ 	}
#@   close $out
#@ 
#@ }
#@ 
#@ define_proc_attributes get_lib_grid_points \
#@     -info " Get the qualified grid points based on query parameter" \
#@     -define_args {
#@       {input_csv_file "The input file name contains query parameter" input_csv_file string required}
#@       {output_csv_file "The output file name for query result" output_csv_file string required}
#@       {matching_point "Query method: '1' for 1-closest grid point (default), '4' for 4 bucket grid points" matching_point one_of_string {optional value_help {values {1 4}}}}
#@ }
#@ 
#@ ##############################################################################
#@ # proc: write_records_in_csv
#@ # Output the data extracted from SQL database to $out_file csv file
#@ # file_id: fild id from csv filenam $out_file
#@ # arr: collection from SQL query commands
#@ # num_col: number of columns in $out_file
#@ ##############################################################################
#@ proc write_records_in_csv {file_id arr num_col} {
#@   global out_file
#@   set sz [expr [llength $arr]/$num_col]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set val ""
#@     for {set j 0} {$j < $num_col} {incr j} {
#@ 	set val1 [lindex $arr [expr $i*$num_col+$j]]   
#@ 	if {$j == 0} {
#@ 	    set val $val1
#@ 	} else {  
#@ 	    set val [concat $val,$val1]  
#@ 	} 
#@ 	#puts stdout j=$j
#@     }
#@     puts $file_id $val
#@     #puts stdout i=$i
#@   }
#@   #puts stdout "$sz records written to $out_file"
#@ }
#@ 
#@ define_proc_attributes write_records_in_csv -hidden
#@ 
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/.lc_scripts.tcl

#@ source $synopsys_root/auxx/lc/analyze_trend.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/analyze_trend.tcl

#@ ##############################################################################
#@ # Proc: analyze_trend   Author: Synopsys   Date: 2015/12/09
#@ #   analyze the input float array monotonicity trend
#@ #   return a char like "-, /, \, V, ^, N, u, M, W, X"
#@ # float_list: input float list, must be at least 2 members
#@ # -relative_tolerance: relative tolerance, default is 0.01
#@ # -absolute_tolerance: absolute tolerance, default is 0.000001
#@ ##############################################################################
#@ proc analyze_trend { args } {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set float_list $ra(float_list)
#@ 
#@   if { [string length [array names ra -relative_tolerance]] ==0 } {
#@     set rel_tol 0.01
#@   } else {
#@     set rel_tol $ra(-relative_tolerance)
#@   }
#@   if { [string length [array names ra -absolute_tolerance]] ==0 } {
#@     set abs_tol 0.000001
#@   } else {
#@     set abs_tol $ra(-absolute_tolerance)
#@   }
#@   
#@   set count [llength $float_list]
#@   if {$count <= 1} {
#@     echo "Can't analysis: list must have at least 2 members."
#@   }
#@ 
#@   set trend 0
#@   
#@   for { set i 0 } { $i < $count - 1 } { incr i } {
#@     set fa [lindex $float_list $i]
#@     set fb [lindex $float_list $i+1]
#@ 
#@     set gap [expr abs($fa-$fb)]
#@     set rel_gap [expr ($fa+$fb)*0.5*$rel_tol]
#@     
#@     if {$gap <= $abs_tol || $gap <= $rel_gap} {
#@       switch -exact -- $trend {
#@         "0" { set trend "-" }
#@         "-" { set trend "-" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "^" }
#@         "N" { set trend "N" }
#@         "u" { set trend "u" }
#@         "M" { set trend "M" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa > $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "\\" }
#@         "-" { set trend "\\" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "^" }
#@         "V" { set trend "u" }
#@         "^" { set trend "^" }
#@         "u" { set trend "u" }
#@         "N" { set trend "M" }
#@         "M" { set trend "M" }
#@         "W" { set trend "X" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa < $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "/" }
#@         "-" { set trend "/" }
#@         "\\" { set trend "V" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "N" }
#@         "N" { set trend "N" }
#@         "u" { set trend "W" }
#@         "M" { set trend "X" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     }
#@     if {$trend == "X"} {break}
#@   }
#@ 
#@   return $trend
#@ }
#@ 
#@ define_proc_attributes analyze_trend \
#@     -info " Analyze the trend of a float list" \
#@     -define_args {
#@       {float_list "The list contains float array for analysis" float_list list required}
#@       {-relative_tolerance "The relative tolerance for the float equal comparing, default is 0.01." relative_tolerance float optional}
#@       {-absolute_tolerance "The absolute tolerance for the float equal comparing, default is 1e-6." absolute_tolerance float optional}
#@ }
#@ 
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/analyze_trend.tcl

#@ source $synopsys_root/auxx/lc/get_scale.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/get_scale.tcl

#@ ##############################################################################
#@ # Proc: get_time_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified time unit is 1ns
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_time_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fs"    { set val 1e-6 }
#@     "ps"    { set val 1e-3 }
#@     "ns"    { set val 1 }
#@     "us"    { set val 1e3 }
#@     "ms"    { set val 1e6 }
#@     "s"     { set val 1e9 }
#@     "ks"    { set val 1e12 }
#@     default { echo "Error! The unit '$unit' is not a 'time' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_time_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_voltage_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified voltage unit is 1v
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_voltage_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fv"    { set val 1e-15 }
#@     "pv"    { set val 1e-12 }
#@     "nv"    { set val 1e-9 }
#@     "uv"    { set val 1e-6 }
#@     "mv"    { set val 1e-3 }
#@     "v"     { set val 1 }
#@     "kv"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'voltage' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_voltage_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_current_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified current unit is 1a
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_current_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fa"    { set val 1e-15 }
#@     "pa"    { set val 1e-12 }
#@     "na"    { set val 1e-9 }
#@     "ua"    { set val 1e-6 }
#@     "ma"    { set val 1e-3 }
#@     "a"     { set val 1 }
#@     "ka"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'current' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_current_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_power_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified power unit is 1w
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_power_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fw"    { set val 1e-15 }
#@     "pw"    { set val 1e-12 }
#@     "nw"    { set val 1e-9 }
#@     "uw"    { set val 1e-6 }
#@     "mw"    { set val 1e-3 }
#@     "w"     { set val 1 }
#@     "kw"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'power' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_power_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_resistance_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified resistance unit is 1ohm
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_resistance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fohm"    { set val 1e-15 }
#@     "pohm"    { set val 1e-12 }
#@     "nohm"    { set val 1e-9 }
#@     "uohm"    { set val 1e-6 }
#@     "mohm"    { set val 1e-3 }
#@     "ohm"     { set val 1 }
#@     "kohm"    { set val 1e3 }
#@     default  { echo "Error! The unit '$unit' is not a 'resistance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_resistance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_capacitance_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified capacitance unit is 1f
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_capacitance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "ff"    { set val 1e-15 }
#@     "pf"    { set val 1e-12 }
#@     "nf"    { set val 1e-9 }
#@     "uf"    { set val 1e-6 }
#@     "mf"    { set val 1e-3 }
#@     "f"     { set val 1 }
#@     "kf"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'capacitance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_capacitance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_energy_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified energy unit is 1j
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_energy_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fj"    { set val 1e-15 }
#@     "pj"    { set val 1e-12 }
#@     "nj"    { set val 1e-9 }
#@     "uj"    { set val 1e-6 }
#@     "mj"    { set val 1e-3 }
#@     "j"     { set val 1 }
#@     "kj"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'energy' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_energy_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_scale   Author: Synopsys   Date: 2015/12/09
#@ #   This command will analyze the unit in the source library, and return 
#@ #   the scale value from the library unit to the target unit. 
#@ #   If any error happens, return 0.
#@ # -type: Unit type (time| voltage| current | power| capacitance | resistance| energy)
#@ # -target_unit: The target unit for sacle 
#@ #     [float][magnitude][unit]
#@ # -library: The source library.
#@ # For example: get_scale time 10.0ps $lib
#@ # Recommand unit type:
#@ #     For time: 1ps| 1ns
#@ #	    For voltage: 1mv| 1v
#@ #	    For current: 1ua| 1ma| 1a
#@ #	    For power: 1pw| 1nw| 1uw| 1mw
#@ #	    For capacitance: 1ff| 1pf
#@ #	    For resistance: 1ohm| 1kohm
#@ #	    For energy: 1fj| 1pj| 1nj| 1uj
#@ ##############################################################################
#@ proc get_scale { args } {
#@ 
#@   set val 0 
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set type $ra(type)
#@   set target_unit $ra(target_unit)
#@   set library $ra(library)
#@   
#@   # time
#@   if { $type=="time" } {
#@     set t_unit_scale [get_time_scale $target_unit]
#@     set unit [get_lib_attribute $library time_unit]
#@     set s_unit_scale [get_time_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # voltage
#@   } elseif { $type=="voltage" } {
#@     set t_unit_scale [get_voltage_scale $target_unit]
#@     set unit [get_lib_attribute $library voltage_unit]
#@     set s_unit_scale [get_voltage_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # current
#@   } elseif { $type=="current" } {
#@     set t_unit_scale [get_current_scale $target_unit]
#@     set unit [get_lib_attribute $library current_unit]
#@     set s_unit_scale [get_current_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # power
#@   } elseif { $type=="power" } {
#@     set t_unit_scale [get_power_scale $target_unit]
#@     set unit [get_lib_attribute $library leakage_power_unit]
#@     set s_unit_scale [get_power_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # capacitance
#@   } elseif { $type=="capacitance" } {
#@     set t_unit_scale [get_capacitance_scale $target_unit]
#@     # unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set unit [get_lib_attribute $library capacitive_load_unit]
#@     set s_unit_scale [get_capacitance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@     
#@   # resistance
#@   } elseif { $type=="resistance" } {
#@     set t_unit_scale [get_resistance_scale $target_unit]
#@     set unit [get_lib_attribute $library pulling_resistance_unit]
#@     set s_unit_scale [get_resistance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # energy
#@   } elseif { $type=="energy" } {
#@     set t_unit_scale [get_energy_scale $target_unit]
#@     # c_unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set c_unit [get_lib_attribute $library capacitive_load_unit]
#@     set c_unit [get_capacitance_scale $c_unit]
#@     set v_unit [get_lib_attribute $library voltage_unit]
#@     set v_unit_scale [get_voltage_scale $v_unit]
#@     set s_unit_scale [expr $c_unit * $v_unit_scale * $v_unit_scale]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@   }
#@  
#@   return $val
#@   
#@ }
#@ 
#@ define_proc_attributes get_scale \
#@     -info " Get the scaling value from source library to target unit." \
#@     -define_args {
#@       {type "Unit type" type one_of_string {required value_help {values {time voltage current power capacitance resistance energy}}}}
#@       {target_unit "The target unit for scaling" target_unit string required }
#@       {library "The source library object" library list required}
#@ }
#@ 
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/get_scale.tcl

#@ source $synopsys_root/auxx/lc/plot_table.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/plot_table.tcl

#@ ##############################################################################
#@ # 'global' parameters   Author: Synopsys   Date: 2016/9/18
#@ ##############################################################################
#@ 
#@ # temp path to accommodate plot data and script 
#@ set lc_plot_table_base_dir  "/tmp/lc_plot_table_"
#@ set lc_plot_table_list_dirs  ""  ;# a list for tmp dirs
#@ 
#@ # to accommodate PIDs & COMMANDs of xterm being executed
#@ set lc_plot_table_pids      ""
#@ set lc_plot_table_cmds      ""
#@ 
#@ ##############################################################################
#@ # Proc: createUniqueDir   Author: Synopsys   Date: 2016/9/18
#@ #   create one unique folder (without tailing backslash) under temp path
#@ # Return: 
#@ #   path of the created folder
#@ ##############################################################################
#@ proc createUniqueDir {} {
#@   set sDir [pid]
#@   append sDir "_" [clock microseconds]
#@   file mkdir $::lc_plot_table_base_dir$sDir
#@   lappend ::lc_plot_table_list_dirs $sDir
#@   return $::lc_plot_table_base_dir$sDir
#@ }
#@ # This proc is hidden
#@ define_proc_attributes createUniqueDir -hidden
#@ 
#@ ##############################################################################
#@ # Proc: clearSpot   Author: Synopsys   Date: 2016/9/18
#@ #   delete the previous intermediate gnuplot data and script
#@ ##############################################################################
#@ proc clearSpot {} {
#@   # close the previous opened terminals
#@   set i 0
#@   foreach sPid $::lc_plot_table_pids {
#@     # check if pid existed
#@     if { [catch {exec kill -0 $sPid}]==0 } {
#@       set sCmd [lindex $::lc_plot_table_cmds $i]
#@       # check if the COMMAND of the pid is exactly the "xterm ..." which was forked by 'me' (plot_table)  
#@       if { [catch {exec ps u | awk {{for(ii=11;ii<=NF;ii++)printf $ii" ";printf "\n"}} | grep -e ^$sCmd}]==0 } {
#@         # kill the process
#@         catch {exec kill $sPid} msg
#@       }
#@     }    
#@     
#@     incr i
#@   }
#@   set ::lc_plot_table_pids  ""
#@   set ::lc_plot_table_cmds  ""
#@   
#@   # delete the previous intermediate gnuplot data and script
#@   foreach sDir $::lc_plot_table_list_dirs {
#@     file delete -force $::lc_plot_table_base_dir$sDir
#@   }
#@   set ::lc_plot_table_list_dirs  ""
#@ }
#@ # This proc is hidden
#@ define_proc_attributes clearSpot -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotData   Author: Synopsys   Date: 2016/10/28
#@ #   generate plot data
#@ # Arguments:
#@ #   lut     lookup_table object
#@ #   sDat    path of plot data file
#@ #   vSlice  slice info. e.g. "" (no slice specified); "output_voltage 0.0920645"
#@ #   vTol    tolerance curves or surfaces
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotData { lut sDat vSlice vTol } {
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@ 
#@   set nDim [lookup_table dimension $lut]
#@   set vIdx [lookup_table index $lut]
#@   set k 0
#@   
#@   if { [llength $vSlice] == 0 } {
#@     set vVal [lookup_table slice -all $lut]
#@     set vIdx0 [lindex $vIdx 0]
#@     if { $nDim==2 } {
#@       set vIdx1 [lindex $vIdx 1]
#@       foreach i $vIdx0 {
#@         foreach j $vIdx1 {
#@           set v [lindex $vVal $k]
#@           puts -nonewline $pDat "$i $j $v"
#@           foreach sTol $vTol {
#@             regsub -all "V" $sTol $v sTol
#@             puts -nonewline $pDat " [expr $sTol]"
#@           }
#@           puts $pDat ""
#@           incr k
#@         }
#@         puts $pDat ""
#@       }
#@     } else {
#@       foreach i $vIdx0 {
#@         set v [lindex $vVal $k]
#@         puts -nonewline $pDat "$i $v"
#@         foreach sTol $vTol {
#@           regsub -all "V" $sTol $v sTol
#@           puts -nonewline $pDat " [expr $sTol]"
#@         }
#@         puts $pDat ""
#@         incr k
#@       }
#@     }
#@   } else {
#@     set vVal [lookup_table slice $lut -index $vSlice]
#@     if { [string equal [lindex $vSlice 0] [lindex [lookup_table variables $lut] 0]] } {
#@       set vIdxAnother [lindex $vIdx 1]
#@     } else {
#@       set vIdxAnother [lindex $vIdx 0]
#@     }
#@     foreach i $vIdxAnother {
#@       set v [lindex $vVal $k]
#@       puts -nonewline $pDat "$i $v"
#@       foreach sTol $vTol {
#@         regsub -all "V" $sTol $v sTol
#@         puts -nonewline $pDat " [expr $sTol]"
#@       }
#@       puts $pDat ""
#@       incr k
#@     }
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotData -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcs   Author: Synopsys   Date: 2016/10/21
#@ #   generate plot data file for CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sDat              path of plot data file
#@ #   vVarIdx           grid points of the object e.g. {var1 index1 var2 index2}
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   vTol              tolerance curves
#@ #   sOvExpr(up-level) customized equation to derive voltage, it will be set to 
#@ #                     empty if invalid expression. This makes 
#@ #                     genPlotDataForCcsPlotAll() comfortable
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcs { lut sDat vVarIdx fInitV1 vTol } {
#@   upvar sOvExpr sOvExprRef
#@   
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@   
#@   set fLoad -1.0
#@   if { [string equal [lindex $vVarIdx 0] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 1]
#@   } elseif { [string equal [lindex $vVarIdx 2] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 3]
#@   }
#@   
#@   set fVpre $fInitV1
#@   set fI 0.0
#@   set fIpre 0.0
#@   set fT 0.0
#@   set fTpre 0.0
#@   set fV 0.0
#@   
#@   set fTRef [lookup_table slice $lut -data ref -index $vVarIdx]
#@   if { [string length $fTRef]==0 } {
#@     set fTRef 0.0
#@   }
#@   if { [string equal $fTRef "0.0"] } {
#@     set fLoad -1.0
#@   }
#@   set vT [lookup_table slice $lut -data time -index $vVarIdx]
#@   set vI [lookup_table slice $lut -data values -index $vVarIdx]
#@   set nT [llength $vT]
#@   set nI [llength $vI]
#@   if { $nT!=$nI } {
#@     puts "error, size of time ($nT) != size of values ($nI)"
#@     close $pDat
#@     return 0
#@   }
#@   
#@   for { set i 0 } { $i<$nT } { incr i } {
#@     set fT [expr [lindex $vT $i]-$fTRef]
#@     set fI [lindex $vI $i]
#@     if { $fLoad > 0 } {
#@       if { [string length $sOvExprRef]!=0 } {
#@         set sOvExprTmp $sOvExprRef
#@         regsub -all "V1" $sOvExprTmp $fVpre sOvExprTmp
#@         regsub -all "I2" $sOvExprTmp $fI sOvExprTmp
#@         regsub -all "I1" $sOvExprTmp $fIpre sOvExprTmp
#@         regsub -all "T2" $sOvExprTmp $fT sOvExprTmp
#@         regsub -all "T1" $sOvExprTmp $fTpre sOvExprTmp
#@         regsub -all "C" $sOvExprTmp $fLoad sOvExprTmp
#@         if { [string length $sOvExprTmp]==0 } {
#@           set fExpr ""
#@         } else {
#@           set fExpr [expr $sOvExprTmp]
#@         }
#@         if { [string length $fExpr]==0 } {
#@           echo "warning, failed to get result of the process($sOvExprRef) from predefined variables: V1($fVpre), I2($fI), I1($fIpre), T2($fT), T1($fTpre), C($fLoad).\nTurn to use built-in default process(V1+0.5/C*(I2+I1)*(T2-T1))."
#@           set sOvExprRef "" ;# make genPlotDataForCcsPlotAll() comfortable
#@           set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@         } else {
#@           set fV $fExpr
#@         }
#@       } else {
#@         set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@       }
#@       set fVpre $fV
#@       set fIpre $fI
#@       set fTpre $fT
#@     } else {
#@       # "total_output_net_capacitance" is not there?
#@       # or no calculated voltage at all
#@       set fV 0.0
#@     }
#@     puts -nonewline $pDat "$fT $fI $fV"
#@     foreach sTol $vTol {
#@       regsub -all "V" $sTol $fI sTol
#@       puts -nonewline $pDat " [expr $sTol]"
#@     }
#@     puts $pDat ""
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcs -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcsPlotAll   Author: Synopsys   Date: 2016/10/21
#@ #   generate plot data files for all grid points of the CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sFnPrefix         folder (with tailing backslash) to accommodate data file
#@ #   sOvExpr           customized equation to derive voltage
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   vTol              tolerance curves
#@ #   vDat(up-level)    paths of plot data files
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcsPlotAll { lut sFnPrefix sOvExpr fInitV1 vTol } {
#@   # set an alias of up-level parameter, which will point to the same memory of
#@   # the parameter in up-level proc. (I think this is most like using reference
#@   # as function parameter in C++)
#@   upvar vDat vDatRef
#@   set vDatRef ""
#@ 
#@   set vVar [lookup_table variables $lut]  ;# e.g. "input_net_transition total_output_net_capacitance"
#@   set vIdx [lookup_table index $lut]      ;# e.g. "{0.00114139996003 0.00220229988918 ...} {......}"
#@   
#@   # 1d and 2d lookup tables supported by now, sanity check already done in main
#@   # procedure
#@   set nDim [llength $vVar]
#@   ## if { $nDim < 1 || $nDim > 2 } {
#@   ##   return -code error "...\n"
#@   ## }
#@   
#@   set sVar0 [lindex $vVar 0]
#@   set nIdx0Size [llength [lindex $vIdx 0]]
#@   
#@   if { $nDim > 1 } {
#@     set sVar1 [lindex $vVar 1]
#@     set nIdx1Size [llength [lindex $vIdx 1]]
#@   }
#@   
#@   for { set i 0 } { $i<$nIdx0Size } { incr i } {
#@     set fIdx0 [lindex [lindex $vIdx 0] $i]
#@     if { $nDim==1 } {
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       set vVarIdx [ list $sVar0 $fIdx0 ]
#@       set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1 $vTol]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@       lappend vDatRef $sDat
#@     } elseif { $nDim==2 } {
#@       for { set j 0 } { $j<$nIdx1Size } { incr j } {
#@         set fIdx1 [lindex [lindex $vIdx 1] $j]
#@         set sDat $sFnPrefix
#@         append sDat "lut" [expr $i*$nIdx1Size+$j+1] ".dat"
#@         set vVarIdx [ list $sVar0 $fIdx0 $sVar1 $fIdx1 ]
#@         set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1 $vTol]
#@         if { $ret==0 } {
#@           return 0
#@         }
#@         lappend vDatRef $sDat
#@       }
#@     } ;# else 3d ...
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcsPlotAll -hidden
#@ 
#@ ##############################################################################
#@ # Proc: getInfoString   Author: Synopsys   Date: 2016/10/27
#@ #   get information of lookup_table object
#@ # Arguments:
#@ #   lut               lookup_table object
#@ # Return:
#@ #   information string of the object
#@ ##############################################################################
#@ proc getInfoString { lut } {
#@   set sInfo ""
#@   
#@   set sTmpl [lookup_table template_name $lut]
#@   if { [string length $sTmpl]!=0 } {
#@     append sInfo " template(" $sTmpl ")"
#@   }
#@   
#@   set nDim [lookup_table dimension $lut]
#@   set vSize [lookup_table sizes $lut]
#@   if { $nDim>0 } {
#@     append sInfo " size(" [lindex $vSize 0]
#@   }
#@   if { $nDim>1 } {
#@     append sInfo "x" [lindex $vSize 1]
#@   }
#@   if { $nDim>2 } {
#@     append sInfo "x" [lindex $vSize 2]
#@   }
#@   if { $nDim>0 } {
#@     append sInfo ")"
#@   }
#@ 
#@   return $sInfo
#@ }
#@ # This proc is hidden
#@ define_proc_attributes getInfoString -hidden
#@ 
#@ ##############################################################################
#@ # Proc: printFile   Author: Synopsys   Date: 2016/11/25
#@ #   print out file content
#@ # Arguments:
#@ #   sDat               file path
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc printFile { sDat } {
#@   set sDelimit "################################################################################"
#@ 
#@   puts ""
#@   if [catch {open $sDat r} pDat] {
#@     puts "error, failed to open $sDat for read:$pDat"
#@     return 0
#@   }
#@   puts -nonewline "# "
#@   puts [file tail $sDat]
#@   puts $sDelimit
#@   puts [read $pDat]
#@   puts $sDelimit
#@   close $pDat      
#@ 
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes printFile -hidden
#@ 
#@ ##############################################################################
#@ # Proc: plot_table   Author: Synopsys   Date: 2016/9/18
#@ #   plot lookup table(s) in lc_shell, using 'gnuplot'.
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ # Examples:
#@ #   moved to man page: plot_table.3
#@ ##############################################################################
#@ proc plot_table {args} {
#@   # supported after set lc_enable_plot_table true
#@   if { [info exists ::lc_enable_plot_table]!=1 || [string equal -nocase $::lc_enable_plot_table "true"]!=1 } {
#@     return -code error "UIL-100 (error) The command is not enabled. You need to set lc_enable_plot_table beforehand."
#@     ## return ""  ;# well, dummy returned here if not set the enable_variable...
#@   }
#@   # supported in lc_advanced_tcl_mode
#@   if { [info exists ::lc_advanced_tcl_mode]!=1 || [string equal -nocase $::lc_advanced_tcl_mode "true"]!=1 } {
#@     return -code error "UIL-100 (error) The command is not enabled, it's support in advanced tcl mode only."
#@   }
#@   set i 0
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   
#@   # -clear, which is an individual arg
#@   if { [string length [array names ra -clear]] != 0 } {
#@     clearSpot
#@     return "1"
#@   }
#@   
#@   # create one more unique dir for data/script
#@   set sFnPrefix [createUniqueDir]
#@   append sFnPrefix "/"
#@   
#@   # luts: list of lookup tables, which is the main arg
#@   set vLut ""
#@   if { [string length [array names ra luts]] != 0 } {
#@     set vLut $ra(luts)
#@   }
#@   set nObjSize [llength $vLut]
#@   if {$nObjSize < 1} {
#@     return -code error "No lookup table is specified.\n"
#@   }
#@  
#@   #
#@   # sanity check and preparation
#@   #
#@   set bIsCCS 0
#@   set bIsCCSPlotAll 0
#@   set vSlice ""
#@   set nDim 0
#@   set sDat ""
#@   set vDat ""   ;# filenames of data
#@   foreach lut $vLut {
#@     set vSize [lookup_table sizes $lut] ;# e.g. "8" (1d), "8 7" (2d)
#@     if {[llength $vSize] < 1} {
#@       return -code error "Specified object ($lut) is NOT a lookup table.\n"
#@     }
#@     
#@     set nDimTmp [lookup_table dimension $lut]
#@     if { $nDimTmp < 1 || $nDimTmp > 2 } {
#@       # 1d and 2d lookup tables supported by now
#@       return -code error "Not supported for $nDimTmp dimension(s).\n"
#@     }
#@     if {[llength [lookup_table slice $lut -all]] < 1} {
#@       # this is a CCS object
#@       set nDim $nDimTmp
#@       if {$nObjSize > 1} {
#@         return -code error "Multiple lookup tables are not supported for CCS object\n"
#@       }
#@       set bIsCCS 1
#@       # -index, used to specify one slice of CCS object
#@       set vVarIdx ""
#@       if { [string length [array names ra -index]] != 0 } {
#@         set vVarIdx $ra(-index)
#@       }
#@       set nVarIdxSize [llength $vVarIdx]
#@       if { $nVarIdxSize==0 } {
#@         set bIsCCSPlotAll 1
#@       } elseif { $nVarIdxSize==1 } {
#@         # e.g. "0:0"  --> "input_net_transition 0.00726140011102 total_output_net_capacitance 0.000390200002585"
#@         # e.g. "0"    --> "input_net_transition 0.00726140011102"
#@         set vId [split $vVarIdx ":"]
#@         if {[llength $vId] != $nDim} {
#@           return -code error "Specified index ($vVarIdx) is unmatched with the object of $nDim dimension(s).\n"
#@         }
#@         set vVar [lookup_table variables $lut]
#@         set vIdx [lookup_table index $lut]
#@         if { $nDim==1 } {
#@           set vVarIdx [ list [lindex $vVar 0] \
#@             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]] ]
#@         } elseif { $nDim==2 } {
#@           set vVarIdx [ list [lindex $vVar 0] \
#@             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]] \
#@             [lindex $vVar 1] \
#@             [lindex [lindex $vIdx 1] [expr [lindex $vId 1]]] ]
#@         } ;# else 3d ...
#@       } ;# else more than 1 elements in $vVarIdx, leave check to lookup_table. e.g. "input_net_transition 0.00726140011102"
#@     } else {
#@       # this is NOT a CCS object
#@       if { $i > 0 } {
#@         if { $nDimTmp != $nDim } {
#@           return -code error "Different dimension(s) of multiple lookup tables can't be plotted at once.\n"
#@         }
#@         if { [llength $vSlice] != 0 } {
#@           # we assume user uses -slice for multi objects with exactly same index 
#@           if { [llength [lookup_table slice $lut -index $vSlice]] == 0 } {
#@             return -code error "Invalid -slice($vSlice), abort.\n"
#@           }
#@         }
#@       } else {  ;# $i==0
#@         set nDim $nDimTmp
#@         # -slice, used to specify one slice for (non-CCS) 2D lookup tables
#@         if { [string length [array names ra -slice]] != 0 } {
#@           set vSlice $ra(-slice)
#@           if { $nDim!=2 } {
#@             return -code error "-slice($vSlice) is not supported for ($nDim) dimension(s) lookup table, abort.\n"
#@           }
#@           set nSliceSize [llength $vSlice]
#@           if { $nSliceSize==1 } {
#@             # e.g. "0:0"    --> "input_voltage 0.0" (for dc_current)
#@             # e.g. "1:2"    --> "output_voltage 0.0920645"
#@             set vId [split $vSlice ":"]
#@             if {[llength $vId] != 2} {
#@               return -code error "Exactly 2 parts(variable_id:index_id) is needed for -slice($vSlice), abort.\n"
#@             }
#@             set nVarId [expr [lindex $vId 0]]
#@             set nIdxId [expr [lindex $vId 1]]
#@             if { $nVarId<0 || $nVarId>1 } {
#@               return -code error "Only 0 or 1 can be specified for the variable_id(the part before ':') in -slice($vSlice), abort.\n"
#@             }
#@             set vVar [lookup_table variables $lut]  ;# e.g. input_voltage output_voltage
#@             set vIdxN [lindex [lookup_table index $lut] $nVarId]  ;# e.g. {0.0 0.0434696 ... 0.95}
#@             if { $nIdxId<0 || $nIdxId>=[llength $vIdxN] } {
#@               return -code error "Invalid index_id(the part after ':') in -slice($vSlice), abort.\n"
#@             }
#@             set vSlice [ list [lindex $vVar $nVarId] [lindex $vIdxN $nIdxId] ]
#@           } elseif { $nSliceSize==2 } {
#@             if { [llength [lookup_table slice $lut -index $vSlice]] == 0 } {
#@               return -code error "Invalid -slice($vSlice), abort.\n"
#@             }
#@           } else {
#@             return -code error "Invalid -slice($vSlice), abort.\n"
#@           }
#@         }
#@       }
#@     }
#@     if { $bIsCCSPlotAll==0 } {
#@       # prepare filename(s) for data
#@       # this job will be done in genPlotDataForCcsPlotAll for 'ccs-plot-all' 
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       lappend vDat $sDat
#@     }
#@     incr i
#@   }
#@   # -dump sanity check
#@   set bDumpDat 0
#@   set bDumpDem 0
#@   if { [string length [array names ra -dump]] != 0 } {
#@     set sDumpOption $ra(-dump)
#@     if { [string equal $sDumpOption "data"] } {
#@       set bDumpDat 1
#@     } elseif { [string equal $sDumpOption "script"] } {
#@       set bDumpDem 1
#@     } elseif { [string equal $sDumpOption "all"] } {
#@       set bDumpDat 1
#@       set bDumpDem 1
#@     } else {
#@       return -code error "-dump $sDumpOption does not match [ data | script | all ].\n"
#@     }
#@   }
#@  
#@   # -derive_output_voltage, enable voltage curve for CCS object
#@   set bOmitExpr 1
#@   if { [string length [array names ra -derive_output_voltage]] != 0 } {
#@     set bOmitExpr 0
#@   }
#@   if { $bOmitExpr==0 && $bIsCCS==0 } {
#@     echo "warning, -derive_output_voltage option won't work for non-CCS objects, ommitted.\n"
#@     set bOmitExpr 1
#@   }
#@ 
#@   # -derive_output_voltage_equation
#@   set sOvExpr ""  ;# customized expression, empty if N/A or invalid
#@   if { $bOmitExpr==0 && [string length [array names ra -derive_output_voltage_equation]] != 0 } {
#@     set sOvExpr $ra(-derive_output_voltage_equation)
#@   }
#@   
#@   # -legend, to customize legends
#@   set itLegend ""
#@   if { [string length [array names ra -legend]] != 0 } {
#@     set itLegend $ra(-legend) ;# it* is actually list_*
#@   }
#@   set vLegend ""              ;# v* is also list_*
#@   set sLegend ""
#@ 
#@   # -initv1, Vss(Vdd) as initial V1 for derived voltage
#@   set fInitV1 0.0
#@   if { [string length [array names ra -initv1]] != 0 } {
#@     set fInitV1 $ra(-initv1)
#@   }
#@   
#@   # -tol, to add tolerance curves or surfaces, currently +-*/ supported
#@   set vTol ""
#@   if { [string length [array names ra -tol]] != 0 } {
#@     set itEq $ra(-tol)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "V" $sEqTmp -1.67345 sEqTmp
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         lappend vTol $sEq
#@       } else {
#@         echo "warning, no.[expr $i+1] -tol equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable name V is used as the default independent variables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@ 
#@   #
#@   # generate data, prepare legends for plotting
#@   #
#@   set i 0
#@   foreach lut $vLut {
#@     if { $bIsCCSPlotAll==1 } {
#@       set ret [genPlotDataForCcsPlotAll $lut $sFnPrefix $sOvExpr $fInitV1 $vTol]
#@     } elseif { $bIsCCS==1 } {
#@       set ret [genPlotDataForCcs $lut [lindex $vDat 0] $vVarIdx $fInitV1 $vTol]
#@     } else {
#@       set ret [genPlotData $lut [lindex $vDat $i] $vSlice $vTol]
#@     }
#@     if { $ret==0 } {
#@       return 0
#@     }
#@ 
#@     # initialize legend for non-CCS object(s)
#@     if { $bIsCCS==0 } {
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         set sLegend "lut"
#@         append sLegend [expr $i+1]
#@       }
#@       append sLegend [getInfoString $lut]
#@       if { [llength $vSlice]!=0 } {
#@         append sLegend " slice"
#@       }
#@       lappend vLegend $sLegend
#@     }
#@     incr i
#@   }
#@   # initialize legends for CCS object
#@   if { $bIsCCS==1 } {
#@     for { set i 0 } { $i<2 } { incr i } {
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         if { $i==0 } {
#@           set sLegend "y= current"
#@         } elseif { [string length $sOvExpr]==0 } {
#@           set sLegend "y2= V1+0.5/C*(I2+I1)*(T2-T1)"
#@         } else {
#@           set sLegend "y2= $sOvExpr"
#@         }
#@       }
#@       lappend vLegend $sLegend
#@     }
#@   }
#@   
#@   # -aux, to add auxiliary curves or surfaces, currently +-*/ supported
#@   set sAuxAppend ""
#@   if { [string length [array names ra -aux]] != 0 } {
#@     set itEq $ra(-aux)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 && [llength $vSlice]==0 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         append sAuxAppend "," $sEq
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend " title \"y= $sEq\" axes x1y1"  ;# plot auxiliaries to 1st Y-Axis for CCS
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   # -aux2, to add auxiliary curves to 2nd Y-Axis for CCS only, currently +-*/ supported
#@   if { [string length [array names ra -aux2]] != 0 } {
#@     set itEq $ra(-aux2)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 && [llength $vSlice]==0 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend "," $sEq
#@           append sAuxAppend " title \"y2= $sEq\" axes x1y2"  ;# plot auxiliaries to 2nd Y-Axis for CCS only
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux2 equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   
#@   # -title, -xlabel, -ylabel, -y2label, several simple 'string' arguments
#@   set sTitle ""
#@   if { [string length [array names ra -title]] != 0 } {
#@     set sTitle $ra(-title)
#@   }
#@   set sXlabel ""
#@   if { [string length [array names ra -xlabel]] != 0 } {
#@     set sXlabel $ra(-xlabel)
#@   }
#@   set sYlabel ""
#@   if { [string length [array names ra -ylabel]] != 0 } {
#@     set sYlabel $ra(-ylabel)
#@   }
#@   set sY2label ""
#@   if { [string length [array names ra -y2label]] != 0 } {
#@     set sY2label $ra(-y2label)
#@   }
#@   
#@   #
#@   # generate main script 'lut.dem'
#@   #
#@   set sDem $sFnPrefix
#@   append sDem "lut.dem"
#@   if [catch {open $sDem w} pDem] {
#@     puts "error, failed to open $sDem for write:$pDem"
#@     return 0
#@   }
#@   puts $pDem "reset"  ;# reset graph-related options to default
#@   if { [string length $sAuxAppend]!=0 } {
#@     if { $bIsCCS==0 && $nDim==2 && [llength $vSlice]==0 } {
#@       puts $pDem "set dummy X,Y"
#@     } else {
#@       puts $pDem "set dummy X"
#@     }
#@   }
#@   if { $bIsCCSPlotAll==1 } {
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     append sTitle [lindex $vLegend 0]
#@     if { $bOmitExpr==0 } {
#@       append sTitle " vs. " [lindex $vLegend 1]
#@     }
#@     append sTitle [getInfoString $lut]
#@     puts -nonewline $pDem "set multiplot title \"$sTitle\" layout [lindex $vSize 0],"
#@     if { $nDim==1 } {
#@       puts $pDem "1"
#@     } elseif { $nDim==2 } {
#@       puts $pDem "[lindex $vSize 1]"
#@     } ;# else 3d ... (e.g. 5*8*7, maybe 5 windows popped-up?)
#@     puts $pDem "unset border\nunset tics\nunset key"
#@     foreach sDat $vDat {
#@       puts -nonewline $pDem "plot \'$sDat\' u 1:2 with lines"
#@       if { $bOmitExpr==0 } {
#@         puts -nonewline $pDem ", \'$sDat\' u 1:3 with lines axes x1y2"
#@       }
#@       set nTolId 4  ;# tolerance data begin at 4th column for CCS object
#@       foreach sTol $vTol {
#@         puts -nonewline $pDem ", \'$sDat\' u 1:$nTolId with lines"
#@         incr nTolId
#@       }
#@       puts $pDem " $sAuxAppend"
#@     }
#@     puts $pDem "unset multiplot"
#@   } elseif { $bIsCCS==1 } {
#@     puts $pDem "set ytics nomirror"
#@     puts $pDem "set y2tics"
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     foreach vectorVarIndex_i $vVarIdx {
#@       append sTitle $vectorVarIndex_i " "
#@     }
#@     puts $pDem "set title \"$sTitle\""
#@     if { [string length $sXlabel]==0 } {
#@       set sXlabel "time_adjust(T=time-reference_time)"
#@     }
#@     puts $pDem "set xlabel \'$sXlabel\'"
#@     if { [string length $sYlabel]==0 } {
#@       set sYlabel "current(I=vVal)"
#@     }
#@     puts $pDem "set ylabel \'$sYlabel\'"
#@     if { $bOmitExpr==0 } {
#@       if { [string length $sY2label]==0 } {
#@         set sY2label "Vout"
#@       }
#@       puts $pDem "set y2label \'$sY2label\'"
#@     }
#@     puts -nonewline $pDem "plot \'[lindex $vDat 0]\' using 1:2 with linespoints title \"[lindex $vLegend 0]\""
#@     if { $bOmitExpr==0 } {
#@       puts -nonewline $pDem ", \'[lindex $vDat 0]\' using 1:3 with linespoints title \"[lindex $vLegend 1]\" axes x1y2"
#@     }
#@     set nTolId 4  ;# tolerance data begin at 4th column for CCS object
#@     foreach sTol $vTol {
#@       puts -nonewline $pDem ", \'[lindex $vDat 0]\' u 1:$nTolId with linespoints title \"[lindex $vLegend 0] $sTol\""
#@       incr nTolId
#@     }
#@     puts $pDem " $sAuxAppend"
#@   } else {
#@     if { [llength $vSlice]!=0 } {
#@       if { [string length $sTitle]!=0 } {
#@         append sTitle "\\n"
#@       }
#@       append sTitle "slice(" $vSlice ")"
#@     }
#@     if { [string length $sTitle]!=0 } {
#@       puts $pDem "set title \"$sTitle\""
#@     }
#@     if { $nDim==2 && [llength $vSlice]==0 } {
#@       # Synopsys 18:29 2016/10/28
#@       # !!!LOOK OUT!!! in next line the letter before 'nonewline' is a '–' which
#@       # is NOT A CORRECT dash symbol '-':
#@       ## puts –nonewline $pDem "set hidden3d\n"
#@       puts $pDem "set hidden3d"
#@       # removed -nogrid, raw data is shown as default, jizhan, Sep 13 2017
#@       ## if { [string length [array names ra -nogrid]] == 0 } {
#@       ##   puts $pDem "set dgrid3d 50,50,4"
#@       ## }
#@       # the following line may 'hide' xyplane at start-up of plot, so comment it out
#@       ## puts $pDem "set xyplane at 0.0"
#@     }
#@     if { $nDim==2 } {
#@       if { [string length $sYlabel]==0 } {
#@         set vVar [lookup_table variables $lut]
#@         set sYlabel [lindex $vVar 1]
#@       }
#@     }
#@     if { [string length $sXlabel]==0 } {
#@       set vVar [lookup_table variables $lut]
#@       set sXlabel [lindex $vVar 0]
#@     }
#@     if { [llength $vSlice]!=0 } {
#@       if { [string equal [lindex $vSlice 0] [lindex [lookup_table variables $lut] 0]] } {
#@         puts $pDem "set xlabel \'$sYlabel\'"
#@       } else {
#@         puts $pDem "set xlabel \'$sXlabel\'"
#@       }
#@     } else {
#@       puts $pDem "set xlabel \'$sXlabel\'"
#@       if { [string length $sYlabel]!=0 } {
#@         puts $pDem "set ylabel \'$sYlabel\'"
#@       }
#@     }
#@     if { $nDim==2 && [llength $vSlice]==0 } {
#@       puts -nonewline $pDem "splot "
#@       set nTolBgnId 4   ;# tolerance data begin at 4th column for 3D plot
#@     } else {
#@       puts -nonewline $pDem "plot "
#@       set nTolBgnId 3   ;# tolerance data begin at 3rd column for 2D plot
#@     }
#@     for { set i 0 } { $i<$nObjSize } { incr i } {
#@       if { $i>0 } {
#@         puts -nonewline $pDem ", "
#@       }
#@       puts -nonewline $pDem "\'[lindex $vDat $i]\' with linespoints title \"[lindex $vLegend $i]\""
#@       set nTolId $nTolBgnId
#@       foreach sTol $vTol {
#@         if { $nTolBgnId==4 } {
#@           puts -nonewline $pDem ", \'[lindex $vDat $i]\' using 1:2:$nTolId with linespoints title \"[lindex $vLegend $i] $sTol\""
#@         } else {
#@           puts -nonewline $pDem ", \'[lindex $vDat $i]\' using 1:$nTolId with linespoints title \"[lindex $vLegend $i] $sTol\""
#@         }
#@         incr nTolId
#@       }
#@     }
#@     puts $pDem "$sAuxAppend"
#@   }
#@   close $pDem
#@ 
#@   #
#@   # generate a wrapper script 'lut.demw', which sets env. and loads 'lut.dem'
#@   #
#@   set sDemw $sFnPrefix
#@   append sDemw "lut.demw"
#@   if [catch {open $sDemw w} pDemw] {
#@     puts "error, failed to open $sDemw for write:$pDemw"
#@     return 0
#@   }
#@   # save to image file (you need to plot-to-file before plot-to-X11, only 
#@   # the last one being plotted is interactivable!)
#@   set sImgFile ""
#@   if { [string length [array names ra -save]] != 0 } {
#@     set sImgFile $ra(-save)
#@   }
#@   set sCurDir [pwd]
#@   if { [string length $sImgFile]!=0 } {
#@     puts $pDemw "set term png small"
#@     if { [string equal [file pathtype $sImgFile] "absolute"] } {
#@       puts $pDemw "set output \'$sImgFile\'"
#@     } else {
#@       puts $pDemw "set output \'$sCurDir/$sImgFile\'"
#@     }
#@     puts $pDemw "load \'$sDem\'"
#@   }
#@   puts $pDemw "set term X11"    ;# to plot to X11
#@   puts $pDemw "load \'$sDem\'"
#@ 
#@   close $pDemw
#@   
#@   #
#@   # execute 'gnuplot' or dump data/script
#@   #
#@   if { $bDumpDat==0 && $bDumpDem==0 } {
#@     cd $sFnPrefix
#@     lappend ::lc_plot_table_pids [exec xterm -e "gnuplot $sDemw -" &]
#@     lappend ::lc_plot_table_cmds "xterm -e gnuplot $sDemw - "
#@     cd $sCurDir
#@   } else {
#@     if { $bDumpDat==1 } {
#@       foreach sDat $vDat {
#@         printFile $sDat
#@       }
#@     }
#@     if { $bDumpDem==1 } {
#@       printFile $sDem
#@       printFile $sDemw
#@     }
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden by now
#@ define_proc_attributes plot_table -hidden \
#@     -info "plot lookup table(s) by gnuplot." \
#@     -define_args {
#@       {luts "lookup table object variables" "object_list" list optional}
#@       {-aux "add auxiliary curves or surfaces by equations" "equation_list" list optional}
#@       {-aux2 "add auxiliary curves aligning to 2nd Y-Axis for CCS only" "equation_list" list optional}
#@       {-derive_output_voltage "add output voltage curve which is derived upon default equation: V1+0.5*(I2+I1)*(T2-T1)/C" "" boolean optional}
#@       {-derive_output_voltage_equation "customize the equation to derive output voltage curve" "equation" string optional}
#@       {-initv1 "provide Vss(Vdd) as initial V1 for derived voltage" "Vss(Vdd)" string optional}
#@       {-index "define grid points for CCS only" "{variable1 index1 variables2 index2}|index1_id:index2_id" string optional}
#@       {-title "title for the plot chart" "title" string optional}
#@       {-xlabel "label of x-axis for the plot chart" "xlabel" string optional}
#@       {-ylabel "label of y-axis for the plot chart" "ylabel" string optional}
#@       {-y2label "label of y2-axis for the plot chart" "y2label" string optional}
#@       {-legend "legends for lookup table" "legend_list" list optional}
#@       {-save "save to image file in png format" "png_file_path" string optional}
#@       {-clear "close all opened terminals and remove all intermediate data" "" boolean optional}
#@       {-dump "print out data and/or scripts generated, instead of plot them" "data|script|all" string optional}
#@       {-slice "plot one slice for (non-CCS) 2D lookup tables" "{variable index}|variable_id:index_id" string optional}
#@       {-tol "add tolerance curves or surfaces by equations" "equation_list" list optional}
#@ }
#@ ## {-nogrid "disable grid data mapping (to 50x50) for 3D data, show original data instead" "" boolean optional}
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/plot_table.tcl

#@ source $synopsys_root/auxx/lc/report_check_library_records.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/report_check_library_records.tcl

#@ ##############################################################################
#@ # 'global' parameters   Author: Synopsys   Date: 2020/9/18
#@ ##############################################################################
#@ array set libchk_code_array { 
#@              1 LIBCHK-300 2 LIBCHK-301 3 LIBCHK-303 4 LIBCHK-304 5 LIBCHK-307 
#@              6 LIBCHK-310 7 LIBCHK-311 8 LIBCHK-312 9 LIBCHK-313 10 LIBCHK-314 
#@              11 LIBCHK-320 12 LIBCHK-321 13 LIBCHK-322 14 LIBCHK-323 15 LIBCHK-330 
#@              16 LIBCHK-331 17 LIBCHK-340 18 LIBCHK-341 19 LIBCHK-342 20 LIBCHK-343 
#@              21 LIBCHK-344 22 LIBCHK-345 23 LIBCHK-345 24 LIBCHK-346 25 LIBCHK-347 
#@              26 LIBCHK-350 27 LIBCHK-352 28 LIBCHK-353 29 LIBCHK-354 30 LIBCHK-355 
#@              31 LIBCHK-356 32 LIBCHK-357 33 LIBCHK-358 34 LIBCHK-359 35 LIBCHK-365 
#@              36 LIBCHK-210 37 LIBCHK-211 38 LIBCHK-212 39 LIBCHK-212 40 LIBCHK-213 
#@              41 LIBCHK-214 42 LIBCHK-215 43 LIBCHK-216 44 LIBCHK-217 45 LIBCHK-201
#@              46 LIBCHK-112}
#@ 
#@ # libchk_code_array, sql_full_table_array and sql_full_table_description is 1:1 map
#@ proc get_index_for_libchk_code {libchk_code} {
#@   global libchk_code_array
#@   
#@   set idx ""
#@   set i 0
#@   set code ""
#@   # skip LIBCHK-307 it is internal table
#@   if {$libchk_code == "LIBCHK-307"} { 
#@     return $idx;
#@   }
#@   foreach {i code} [array get libchk_code_array] {
#@     #puts "The corresponding number of $i is $code."
#@     if {$code == $libchk_code} {
#@       lappend idx $i
#@     }
#@   }
#@   return $idx
#@ }
#@ define_proc_attributes get_index_for_libchk_code -hidden 
#@ 
#@ proc get_sql_full_table_by_idx {idx} {
#@   array set sql_full_table_array {1 libchk300_mismatched_libs_slg \
#@                                 2 libchk301_operating_cond  \
#@                                 3 libchk303_missing_libs_slg \
#@                                 4 libchk304_scaling_lib_groups \
#@                                 5 libchk307_misc \
#@                                 6 libchk310_missing_cells_slg \
#@                                 7 libchk311_mismatched_cells_slg \
#@                                 8 libchk312_cell_classification \
#@                                 9 libchk313_missing_hvth \
#@                                 10 libchk314_mb_vs_sb_cells \
#@                                 11 libchk320_missing_pins_slg \
#@                                 12 libchk321_mismatched_pins_slg \
#@                                 13 libchk322_mismatched_pg_pins_slg \
#@                                 14 libchk323_missing_pg_pins_slg \
#@                                 15 libchk330_missing_arcs \
#@                                 16 libchk331_mismatched_arcs \
#@                                 17 libchk340_noise_model \
#@                                 18 libchk341_power_model \
#@                                 19 libchk342_ccsn_vs_nldm \
#@                                 20 libchk343_sensitivity \
#@                                 21 libchk344_value_range \
#@                                 22 libchk345_pg_current_ratio \
#@                                 23 libchk345_ccsp_time_ratio \
#@                                 24 libchk346_ccsn_vs_ccst \
#@                                 25 libchk347_c1cn_vs_c1c2 \
#@                                 26 libchk350_ccst_vs_nldm \
#@                                 27 libchk352_lvf \
#@                                 28 libchk353_stats_analysis \
#@                                 29 libchk354_table_trend \
#@                                 30 libchk355_table_bound \
#@                                 31 libchk356_table_slope \
#@                                 32 libchk357_table_index \
#@                                 33 libchk358_interpolation \
#@                                 34 libchk359_voltage_range \
#@                                 35 libchk365_summary \
#@                                 36 libchk210_missing_logic_cells \
#@                                 37 libchk211_missing_phys_cells \
#@                                 38 libchk212_missing_logic_pins \
#@                                 39 libchk212_missing_phys_pins \
#@                                 40 libchk213_mismatched_pins \
#@                                 41 libchk214_bus_naming_style \
#@                                 42 libchk215_cell_footprint \
#@                                 43 libchk216_mismatched_cell_area \
#@                                 44 libchk217_mismatched_cells \
#@                                 45 libchk201_library_list \
#@                                 46 libchk112_same_name_cells}
#@ 
#@   set full_table ""
#@   set sz [llength $idx]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set ii [lindex $idx $i]
#@     lappend full_table $sql_full_table_array($ii)
#@   }
#@   return $full_table
#@ }
#@ define_proc_attributes get_sql_full_table_by_idx -hidden 
#@ 
#@ proc get_description_for_table_by_idx {idx} {
#@ array set sql_full_table_description {
#@   1 {List of inconsistent library group data (LIBCHK-300)}  \
#@   2 {List of incompliant operating conditions (LIBCHK-301)} \
#@   3 {Missing libraries in scaling groups (LIBCHK-303)} \
#@   4 {Valid scaling library groups (LIBCHK-304)}  \
#@   5 {List of miscellaneous inconsistent library data (LIBCHK-307)} \
#@   6 {List of cells missing in logic libraries (LIBCHK-310)} \
#@   7 {List of cells with mismatched or missing attributes in logic libraries (LIBCHK-311)} \
#@   8 {List of cell classification (LIBCHK-312)} \
#@   9 {List of function groups missing high threshold_voltage_group cells (LIBCHK-313)} \
#@   10 {List of mapping multi bit to single bit cells (LIBCHK-314)} \
#@   11 {List of pins missing in logic libraries (LIBCHK-320)} \
#@   12 {List of pins with mismatched or missing attributes in logic libraries (LIBCHK-321)} \
#@   13 {List of pg_pins with mismatched or missing attributes in logic libraries (LIBCHK-322)} \
#@   14 {List of pg_pins missing in logic libraries (LIBCHK-323)} \
#@   15 {List of timing arcs missing or existing in libraries (LIBCHK-330)} \
#@   16 {List of timing arcs mismatched in logic libraries (LIBCHK-331)} \
#@   17 {List of inconsistent CCS noise models (LIBCHK-340)} \
#@   18 {List of inconsistent power models (LIBCHK-341)} \
#@   19 {List of inconsistent data between CCS noise and NLDM models (LIBCHK-342)} \
#@   20 {List of sensitive CCSN models (LIBCHK-343)} \
#@   21 {Table of attribute value range analysis (LIBCHK-344)} \
#@   22 {Table of pg current value ratios. (LIBCHK-345)} \
#@   23 {Table of ccsp time value ratios. (LIBCHK-345)} \
#@   24 {List of inconsistent data between CCS noise and CCS timing models (LIBCHK-346)} \
#@   25 {List of inconsistent receiver_capacitance C1/C2 (LIBCHK-347)} \
#@   26 {List of inconsistent data between different timing models (LIBCHK-350)} \
#@   27 {Table of LVF model analysis (LIBCHK-352)} \
#@   28 {Report of the statistical analysis results of characterization models (LIBCHK-353)}  \
#@   29 {Table of characterization table trend analysis (LIBCHK-354)} \
#@   30 {Table of characterization table bound analysis (LIBCHK-355)} \
#@   31 {Table of characterization table slope analysis (LIBCHK-356)} \
#@   32 {Table of characterization table index analysis (LIBCHK-357)} \
#@   33 {Table of interpolation accuracy analysis (LIBCHK-358)} \
#@   34 {Table of partial voltage ranges on timing arcs (LIBCHK-359)} \
#@   35 {Statistical analysis summary table (LIBCHK-365)} \
#@   36 {List of cells missing in logic library (LIBCHK-210)} \
#@   37 {List of cells missing in physical library (LIBCHK-211)} \
#@   38 {List of pins missing in logic library (LIBCHK-212)} \
#@   39 {List of pins missing in physical library (LIBCHK-212)} \
#@   40 {List of pins mismatched in logic and physical libraries (LIBCHK-213)} \
#@   41 {List of bus naming styles (LIBCHK-214)} \
#@   42 {List of cells with cell_footprint attribute (LIBCHK-215)} \
#@   43 {List of cells with inconsistent area (LIBCHK-216)} \
#@   44 {List of cells mismatched in logic and physical libraries (LIBCHK-217)} \
#@   45 {List of logic and physical libraries} \
#@   46 {List of cells with same names (LIBCHK-112)}}
#@   set desp ""
#@   set sz [llength $idx]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set ii [lindex $idx $i]
#@     lappend desp $sql_full_table_description($ii)
#@   }
#@   return $desp
#@ 
#@ }
#@ define_proc_attributes get_description_for_table_by_idx -hidden 
#@ 
#@ proc print_column_names_for_table {file_id tbl_info exclude_cols sep} {
#@   set sz [llength $tbl_info]
#@   set col [expr {$sz/6}]
#@   set num_cols 0
#@   set idx 0
#@   set col_names ""
#@   while {$idx < $col} {
#@     set one_col [lindex $tbl_info [expr $idx * 6 +1] ]
#@     # If $one_col is in $exclude_cols, do not add it to $col_names
#@     if {[lsearch -exact $exclude_cols $one_col] < 0} {
#@       if {$idx == 0} {
#@         set col_names $one_col
#@       } else {
#@         set col_names [concat $col_names$sep$one_col]
#@       }
#@       incr num_cols
#@     }
#@     incr idx
#@   }
#@ 
#@   if {[llength $file_id] > 0} {
#@       puts $file_id  $col_names
#@   }
#@   return [list $num_cols $col_names]
#@ }
#@ define_proc_attributes print_column_names_for_table -hidden 
#@ 
#@ proc print_records_for_table {file_id arr num_col sep} {
#@   set sz [expr [llength $arr]/$num_col]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set val ""
#@     for {set j 0} {$j < $num_col} {incr j} {
#@       set val1 [lindex $arr [expr $i*$num_col+$j]]   
#@       if {$j == 0} {
#@         set val $val1
#@       } else {  
#@         set val [concat $val$sep$val1]  
#@       } 
#@     }
#@     puts $file_id $val
#@   }
#@ }
#@ define_proc_attributes print_records_for_table -hidden 
#@ 
#@ ##############################################################################
#@ # Proc: report_check_library_records Author: Synopsys   Date: 2020/9/2
#@ #   This command is to report library checking results stored in sqlite database
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ ##############################################################################
#@ proc report_check_library_records {args} {
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set options ""
#@   set lc_advanced_tcl_mode true
#@   set sql_file $ra(sql_filename)
#@   set verbose ""
#@   if {[string length [array names ra -verbose]] != 0} {
#@     set verbose  1
#@   }
#@   # list of sql tables to report
#@   # sql_table_list and desp_list should 1:1 map 
#@   set sql_table_list ""
#@   global libchk_code_array
#@   set support_table_list ""
#@   foreach {index code} [array get libchk_code_array] {
#@     set support_table_list [concat $support_table_list $code]
#@   }
#@   set desp_list ""
#@   set libchk_code_defined 0
#@   set char_integrity_defined 0
#@   set logic_defined 0
#@   set logic_vs_physical_defined 0
#@   if {[string length [array names ra -libchk_codes]] != 0} {
#@     set error_codes $ra(-libchk_codes)
#@     set libchk_code_defined 1 
#@     if {[llength $error_codes] < 1} {
#@       return -code error "-libchk_codes should be a list of libchk error code, in the format of LIBCHK-3XX or LIBCHK-2XX\n"
#@     }
#@     foreach code $error_codes {
#@       set idx [get_index_for_libchk_code $code]
#@       if {[llength $idx] < 1 } {
#@         puts "Warning : Ignore invalid libchk_code $code!\n"
#@         puts "Supported libchk_codes are : $support_table_list\n"
#@ 
#@         continue
#@       }
#@       set full_table [get_sql_full_table_by_idx $idx]
#@       if {[llength $full_table] <1} {
#@         # make sure code and table is consistent
#@         puts "Warning : Ignore invalid libchk_code $code!\n"
#@         puts "Supported libchk_codes are : $support_table_list\n"
#@         continue
#@       }
#@       set tmp_desp [get_description_for_table_by_idx $idx]
#@       foreach tbl $full_table {
#@         set sql_table_list [concat $sql_table_list $tbl]
#@         set desp_list [concat $desp_list $tmp_desp]
#@       }
#@     }
#@   }
#@       
#@   if {[string length [array names ra -char_integrity]] != 0} {
#@     set char_integrity_defined 1 
#@     lappend sql_table_list "libchk342_ccsn_vs_nldm"
#@     lappend sql_table_list "libchk343_sensitivity"
#@     lappend sql_table_list "libchk350_ccst_vs_nldm"
#@     lappend sql_table_list "libchk358_interpolation"
#@     lappend sql_table_list "libchk359_voltage_range"
#@     lappend desp_list [get_description_for_table_by_idx 19]
#@     lappend desp_list [get_description_for_table_by_idx 20]
#@     lappend desp_list [get_description_for_table_by_idx 26]
#@     lappend desp_list [get_description_for_table_by_idx 33]
#@     lappend desp_list [get_description_for_table_by_idx 34]
#@   }
#@   if {[string length [array names ra -logic]] != 0} {
#@     set logic_defined 1 
#@     lappend sql_table_list "libchk300_mismatched_libs_slg"
#@     lappend sql_table_list "libchk301_operating_cond"
#@     lappend sql_table_list "libchk303_missing_libs_slg"
#@     lappend sql_table_list "libchk304_scaling_lib_groups"
#@     lappend sql_table_list "libchk310_missing_cells_slg"
#@     lappend sql_table_list "libchk311_mismatched_cells_slg"
#@     lappend sql_table_list "libchk312_cell_classification"
#@     lappend sql_table_list "libchk313_missing_hvth"
#@     lappend sql_table_list "libchk314_mb_vs_sb_cells"
#@     lappend sql_table_list "libchk320_missing_pins_slg"
#@     lappend sql_table_list "libchk321_mismatched_pins_slg"
#@     lappend sql_table_list "libchk322_mismatched_pg_pins_slg"
#@     lappend sql_table_list "libchk323_missing_pg_pins_slg"
#@     lappend sql_table_list "libchk330_missing_arcs"
#@     lappend sql_table_list "libchk331_mismatched_arcs"
#@     lappend sql_table_list "libchk340_noise_model"
#@     lappend sql_table_list "libchk341_power_model"
#@     lappend sql_table_list "libchk347_c1cn_vs_c1c2"
#@     lappend desp_list [get_description_for_table_by_idx 1]
#@     lappend desp_list [get_description_for_table_by_idx 2]
#@     lappend desp_list [get_description_for_table_by_idx 3]
#@     lappend desp_list [get_description_for_table_by_idx 4]
#@     lappend desp_list [get_description_for_table_by_idx 6]
#@     lappend desp_list [get_description_for_table_by_idx 7]
#@     lappend desp_list [get_description_for_table_by_idx 8]
#@     lappend desp_list [get_description_for_table_by_idx 9]
#@     lappend desp_list [get_description_for_table_by_idx 10]
#@     lappend desp_list [get_description_for_table_by_idx 11]
#@     lappend desp_list [get_description_for_table_by_idx 12]
#@     lappend desp_list [get_description_for_table_by_idx 13]
#@     lappend desp_list [get_description_for_table_by_idx 14]
#@     lappend desp_list [get_description_for_table_by_idx 15]
#@     lappend desp_list [get_description_for_table_by_idx 16]
#@     lappend desp_list [get_description_for_table_by_idx 17]
#@     lappend desp_list [get_description_for_table_by_idx 18]
#@     lappend desp_list [get_description_for_table_by_idx 25]
#@ 
#@   }
#@   if {[string length [array names ra -logic_vs_physical]] != 0} {
#@     set logic_vs_physical_defined 1 
#@     lappend sql_table_list "libchk201_library_list"
#@     lappend sql_table_list "libchk210_missing_logic_cells"
#@     lappend sql_table_list "libchk211_missing_phys_cells"
#@     lappend sql_table_list "libchk212_missing_logic_pins"
#@     lappend sql_table_list "libchk212_missing_phys_pins"
#@     lappend sql_table_list "libchk213_mismatched_pins"
#@     lappend sql_table_list "libchk214_bus_naming_style"
#@     lappend sql_table_list "libchk215_cell_footprint"
#@     lappend sql_table_list "libchk216_mismatched_cell_area"
#@     lappend sql_table_list "libchk217_mismatched_cells"
#@     lappend desp_list [get_description_for_table_by_idx 45]
#@     lappend desp_list [get_description_for_table_by_idx 36]
#@     lappend desp_list [get_description_for_table_by_idx 37]
#@     lappend desp_list [get_description_for_table_by_idx 38]
#@     lappend desp_list [get_description_for_table_by_idx 39]
#@     lappend desp_list [get_description_for_table_by_idx 40]
#@     lappend desp_list [get_description_for_table_by_idx 41]
#@     lappend desp_list [get_description_for_table_by_idx 42]
#@     lappend desp_list [get_description_for_table_by_idx 43]
#@     lappend desp_list [get_description_for_table_by_idx 44]
#@   }
#@   # by default output summary from 312, 310, 353 table
#@   if {[llength $sql_table_list] < 1} {
#@     set sql_table_list "libchk312_cell_classification"
#@     lappend sql_table_list "libchk310_missing_cells_slg"
#@     lappend sql_table_list "libchk353_stats_analysis"
#@     set desp_list [get_description_for_table_by_idx 8]
#@     lappend desp_list [get_description_for_table_by_idx 6]
#@     lappend desp_list [get_description_for_table_by_idx 28]
#@   }
#@   if {$libchk_code_defined == 1 }  {
#@      if {$char_integrity_defined == 1} {
#@        return -code error "Error : Cannot specify '-libchk_codes' with '-char_integrity'.(CMD-001)\n"
#@      }
#@ # removed following to enable LIBCHK-112 with -logic -logic_vs_physical
#@ #     if {$logic_defined == 1} {
#@ #       return -code error "Error : Cannot specify '-libchk_codes' with '-logic'.(CMD-001)\n"
#@ #     }
#@ #     if {$logic_vs_physical_defined == 1} {
#@ #       return -code error "Error : Cannot specify '-libchk_codes' with '-logic_vs_physical'.(CMD-001)\n"
#@ #     }
#@   }
#@ 
#@   set cell_list ""
#@   if  {[string length [array names ra -cells]] != 0} {
#@     set cell_list $ra(-cells)
#@     if {[llength $cell_list] < 1} {
#@       return -code error "-cells should be a list of cell names\n"
#@     }
#@   }
#@   set sql_cmd ""
#@   if  {[string length [array names ra -sql_cmd]] != 0} {
#@     set sql_cmd $ra(-sql_cmd)
#@   }
#@   set cell_num [llength $cell_list]
#@   set cell_filter ""
#@   if {$cell_num > 0} {
#@     set idx 0
#@     while {$idx < $cell_num} {
#@       set one_cell "'[lindex $cell_list $idx]'"
#@       if {$idx == 0} {
#@         set cell_filter  $one_cell
#@       } else {
#@         set cell_filter [concat $cell_filter,$one_cell]
#@       }
#@       incr idx
#@     }
#@   }
#@   set cell_clause ""
#@   if {$cell_filter != ""} {
#@     if {$sql_cmd == ""} {
#@         set cell_clause "where cell_name in ($cell_filter)"
#@     } else {
#@         set cell_clause "and cell_name in ($cell_filter)"
#@     }
#@   }
#@   set output_csv 0
#@   if  {[string length [array names ra -report_format]] != 0} {
#@     set format $ra(-report_format)
#@     if {$format != "csv"} {
#@       return -code error "only \"-report_format csv\" is supported."
#@     }
#@     set output_csv 1
#@   }
#@ 
#@   #open sqlite database
#@   sqlite3 db3 $sql_file
#@   puts "\nInformation: Open $sql_file for reporting.\n"
#@ 
#@   set desp_i  0
#@   foreach full_table $sql_table_list {
#@     set tbl_exist [db3 eval "pragma table_info($full_table)"]
#@     set one_desp [string trim [lindex $desp_list $desp_i] "{}"]
#@     incr desp_i
#@     set add_cell_filter_clause 1
#@     #make sure the table has "cell_name" column
#@     if {[lsearch $tbl_exist "cell_name"] < 0} {
#@       set add_cell_filter_clause 0
#@     }
#@ 
#@     set sz [llength $tbl_exist]
#@     if {$sz > 0} {
#@       set col_num [expr {$sz/6}]
#@       set arr1 ""
#@       if {$add_cell_filter_clause == 1 && $cell_clause != ""} {
#@         set arr1 [db3 eval "select * from $full_table $sql_cmd $cell_clause "]
#@         #puts "select * from $full_table $sql_cmd $cell_clause "
#@       } else {
#@         set arr1 [db3 eval "select * from $full_table $sql_cmd"]
#@         #puts "select * from $full_table $sql_cmd "
#@       }
#@ 
#@       set num_records [llength $arr1]
#@       if {$num_records > 0} {
#@         set line_len [expr $col_num*18]
#@         if {$line_len > 140} {
#@           set line_len 140
#@         }
#@         set line_sep [string repeat "-" $line_len]
#@         puts $one_desp 
#@         puts $line_sep
#@         print_column_names_for_table stdout $tbl_exist "" "\t"
#@         puts $line_sep
#@         print_records_for_table stdout $arr1 $col_num "\t"
#@         puts $line_sep
#@         if {$output_csv == 1} {
#@           set out_file [concat out_$full_table.csv]
#@           set file_id [open $out_file w]
#@           print_column_names_for_table $file_id $tbl_exist "" ","
#@           write_records_in_csv $file_id $arr1 $col_num
#@           close $file_id
#@         }
#@       } else {
#@         puts "Warning: no record is print! Please check -sql_cmd is correct if specified!"
#@       }
#@     } elseif {$verbose == 1 || $sql_cmd != ""} {
#@        puts "Warning : Table $full_table does not exist."
#@     }
#@   }
#@   # list all sqlite table names
#@   if {[string length [array names ra -sql_table_list]] != 0} {
#@       set tbl_names [db3 eval "SELECT name FROM sqlite_master"]
#@       puts "The database has [llength $tbl_names] sqlite tables:"
#@       puts stdout $tbl_names
#@   }
#@   db3 close
#@ }
#@ 
#@ define_proc_attributes report_check_library_records \
#@     -info "report check library results" \
#@     -define_args {
#@       {sql_filename "report check library result from the sql database file" "file_name" string required}
#@       {-cells "report check library result for specified cells" "cell_list" list optional}
#@       {-libchk_codes "report check library result for specified LIBCHK codes" "libchk_code_list" list optional}
#@       {-char_integrity "report check library result for char integrity" "" boolean optional}
#@       {-logic "report check library result for logical" "" boolean optional}
#@       {-logic_vs_physical "report check library result for logic vs. physical check" "" boolean optional}
#@       {-sql_cmd "sql command to evaluate in sqlite" "sql_command" string optional}
#@       {-sql_table_list "list all sqlite table names" "" boolean optional}
#@       {-report_format "output file format" "csv" string optional} 
#@       {-verbose "output detail running log" "" boolean optional}
#@ }
#@ 
#@ ################################################################################
#@ # Proc: update_check_library_records Author: Synopsys   Date: 03/01/2021
#@ #   This proc is for incremental updates on fusion libraries:
#@ #   1) remove records for libraries specified in -remove_libs
#@ #   2) merge check library records from sql_filename2 to sql_filename
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ ################################################################################
#@ 
#@ proc update_check_library_records {args} {
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set options ""
#@   set lc_advanced_tcl_mode true
#@   set sql_file $ra(sql_filename)
#@   set verbose ""
#@   if {[string length [array names ra -verbose]] != 0} {
#@     set verbose 1
#@   }
#@ 
#@   if ![file exists $sql_file.bak] {
#@       exec cp $sql_file $sql_file.bak ;# back up original $sql_file if not done so
#@   }
#@ 
#@   set ::FLIB::added_phys_libs ""
#@   set ::FLIB::removed_phys_libs ""
#@   set ::FLIB::added_dbs ""
#@   set ::FLIB::removed_dbs ""
#@ 
#@   #open sqlite databases
#@   sqlite3 db3 $sql_file
#@   set sql_file2 ""			
#@   # open sql_filename2 and merge tables with sql_filename
#@   if {[string length [array names ra sql_filename2]] != 0} {
#@       set sql_file2 $ra(sql_filename2)
#@       if ![file exists $sql_file2.bak] {
#@ 	  exec cp $sql_file2 $sql_file2.bak ;# back up original $sql_file2
#@       }
#@       sqlite3 db3inc $sql_file2
#@       set ::FLIB::added_phys_libs [::FLIB::get_updated_libs "Physi\#" 1]
#@       set ::FLIB::added_dbs [::FLIB::get_updated_libs "Logic\#" 1]
#@   }
#@ 
#@   # map lib_no from inc_db3 to db3 via lib_name for libs replaced
#@   set lib_no_and_names  [db3 eval "select lib_no, lib_name from libchk201_library_list"] ;# Logic#1:lib_name
#@   array set ::FLIB::lib_name2nos [::FLIB::map_lib_name_to_no $lib_no_and_names];# from db3
#@   if {$sql_file2 != ""} {
#@     set tbl_exist [db3inc eval "pragma table_info(libchk201_library_list)"]
#@     if {[llength $tbl_exist] > 0} {
#@       set lib_no_and_names2 [db3inc eval "select lib_no, lib_name from libchk201_library_list"]
#@       array set ::FLIB::lib_no2names [::FLIB::map_lib_no_to_name $lib_no_and_names2] ;# from inc_db3
#@     }
#@   }
#@   set rm_libs ""
#@   if {[string length [array names ra -remove_libs]] != 0} {
#@       set rm_libs $ra(-remove_libs)
#@       # get lib# to lib_name mapping
#@       array set ::FLIB::lib_no2names0 [::FLIB::map_lib_no_to_name $lib_no_and_names]
#@       ::FLIB::remove_libs $rm_libs
#@       set ::FLIB::removed_phys_libs [::FLIB::get_removed_libs "Physi\#" $rm_libs]
#@       set ::FLIB::removed_dbs [::FLIB::get_removed_libs "Logic\#" $rm_libs]
#@   }
#@ 
#@   # open sql_filename2 and merge tables with sql_filename
#@   if {[string length $sql_file2] != 0} {
#@       puts "update_check_library_records $sql_file $sql_file2"
#@       ::FLIB::merge_tables $sql_file $sql_file2 $verbose ;# lib_name2nos lib_no2names
#@   }
#@ 
#@   # update autofix.tcl
#@   ::FLIB::update_autofix_tcl $sql_file $sql_file2
#@   if {$rm_libs != ""} {
#@       puts "update_check_library_records $sql_file $sql_file2 -remove_libs $rm_libs done."
#@   } else {
#@       puts "update_check_library_records $sql_file $sql_file2 done."
#@   }
#@   db3 close
#@ }
#@ 
#@ define_proc_attributes update_check_library_records \
#@     -hidden \
#@     -info "incrementally update check library results in sqlite3 (.db3)" \
#@     -define_args {
#@       {sql_filename "sql file for original check library results" "file_name" string required}
#@       {sql_filename2 "incrementally updated sql file" "file_name" string optional}
#@       {-remove_libs "db in lib[0-9]+ or frame lib name to be removed" "lib_list" list optional}
#@       {-verbose "output detailed check_lib records" "" boolean optional}
#@     }
#@ 
#@ # Get logic or physical lib names from LIBCHK-201 table
#@ # sql_file = autofix0.tcl
#@ # lib_type = 'Logic#' or 'Physi#'
#@ # return list of updated lib names by type or the whole libchk201 table
#@ proc get_lib_names {sql_file {lib_type ""}} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     if {$lib_type == ""} {
#@ 	set flib_sql_list [db3 eval "select * from libchk201_library_list"]
#@     } else {
#@ 	set flib_sql_list [db3 eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@     }
#@     db3 close
#@     return $flib_sql_list
#@ }
#@ define_proc_attributes get_lib_names -hidden
#@ 
#@ proc get_sql_tables {sql_file} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     set tbl_names [db3 eval "SELECT name FROM sqlite_master"]
#@     set flib_sql_list $tbl_names
#@     db3 close
#@     return $tbl_names
#@ }
#@ define_proc_attributes get_sql_tables -hidden
#@ 
#@ 
#@ namespace eval FLIB {
#@ 
#@ #remove records and/or columns for libraries specified in -remove_libs
#@ #also remove autofix lines if issue/record is gone
#@ proc remove_libs {rm_libs} {
#@     set where_cond [remove_lib_where $rm_libs]
#@     set where_cond_phys $where_cond
#@     regsub -all "lib_name" $where_cond_phys "phys_lib" where_cond_phys
#@     set where_cond_logic $where_cond
#@     regsub -all "lib_name" $where_cond_logic "logic_lib" where_cond_logic
#@ 
#@     set tbl_names0 [db3 eval "SELECT name FROM sqlite_master"]
#@     foreach tbl_name $tbl_names0 {
#@ 	if {$tbl_name == "libchk213_mismatched_pins"} {
#@ 	    remove_records_from_table $rm_libs $tbl_name
#@ 	    continue
#@ 	}
#@ 	set tbl_struct [db3 eval "pragma table_info($tbl_name)"]
#@ 	set cols [print_column_names_for_table "" $tbl_struct $rm_libs ","]
#@ 	#set num_cols [lindex $cols 0]
#@ 	set cols [lindex $cols 1]
#@ 	set where_cond2 [ neq_val_where $cols $rm_libs ] ;# e.g. where lib2!=lib1 or lib3!=lib1
#@ 
#@ 	#rename existing table
#@ 	db3 eval "ALTER TABLE $tbl_name RENAME TO ${tbl_name}_old"
#@ 	#create table with the original name
#@ 	if {[lsearch $tbl_struct "lib_name"] >= 0} { ;# if table has lib_name
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond"
#@ 	} elseif {[lsearch $tbl_struct "phys_lib"] >= 0} { ;# if table has phys_lib, i.e. LIBCHK-210, 212
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond_phys"
#@ 	} elseif {[lsearch $tbl_struct "logic_lib"] >= 0} { ;# if table has logic_lib, i.e. LIBCHK-211, 212
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond_logic"
#@ 	} else {			# if record has inconsistent values in lib1, lib2, ...
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond2"
#@ 	    # get consistent removed records in string patterns for scenario 1.2
#@ 	    db3 eval "DELETE FROM ${tbl_name}_old $where_cond2";# delete records stored in new $tbl_name above
#@ 	    variable removed_lines
#@ 	    set removed_lines [get_removed_records $tbl_name]
#@ 	}
#@ 	#remove empty table
#@ 	if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {
#@ 	    db3 eval "drop table if exists $tbl_name"
#@ 	}
#@ 	db3 eval "drop table if exists ${tbl_name}_old";# remove old table after $tbl_name is updated
#@     }
#@ 
#@     if {[info exists db_removed] && $db_removed == 1} {		;# get $extra_db_cells_dbs_removed
#@ 	set tbl_struct [db3 eval "pragma table_info('libchk310_missing_cells_slg')"]
#@ 	set cols [print_column_names_for_table "" $tbl_struct $rm_libs ","]
#@ 	set cols [lindex $cols 1]
#@ 	get_extra_db_cells_dbs_removed "libchk310_missing_cells_slg" $cols $rm_libs
#@     }
#@ }
#@ define_proc_attributes remove_libs -hidden
#@ 
#@ # merge sqlite tables from sql_filename2 to sql_filename, so final tables will have more columns and/or records
#@ proc merge_tables {sql_file sql_file2 verbose} {
#@     db3 eval {attach database $sql_file2 as inc_db3}
#@     set tbl_names0 [db3 eval "SELECT name FROM sqlite_master"]
#@     set tbl_names2 [db3inc eval "SELECT name FROM sqlite_master"]
#@     set tbl_names [lsort -unique [list {*}$tbl_names0 {*}$tbl_names2]] ;# union of tbl names from db3 and db3inc
#@     foreach tbl_name $tbl_names {
#@ 	if {$tbl_name == "libchk210_missing_logic_cells" || $tbl_name == "libchk211_missing_phys_cells"} {
#@ 	    merge_table2 $tbl_name
#@ 	} elseif {[lsearch $tbl_names0 $tbl_name] >= 0 && [lsearch $tbl_names2 $tbl_name] >= 0} { ;# if both sql_file and sql_file2 have same name table 
#@ 	    merge_table $tbl_name $verbose
#@ 	} elseif {[lsearch $tbl_names2 $tbl_name] >= 0} { ;# if only sql_file2 has the table, copy it to sql_file
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT * FROM inc_db3.$tbl_name" ;# add to autofix.tcl
#@ 	}
#@ 	# if sql_file2 has no same name table, i.e. the table is only in sl_file, keep it in db3
#@     }
#@     if {$verbose == 1} {
#@ 	puts "The primary sql database $sql_file has [llength $tbl_names0] tables."
#@ 	puts "The second sql database $sql_file2 has [llength $tbl_names2] tables."
#@ 	puts "The merged sql database has [llength $tbl_names] tables:\n$tbl_names"
#@     }
#@ }
#@ define_proc_attributes merge_tables -hidden
#@ 		
#@ # if both sql_file and sql_file2 have same name table, merge it to sql_file
#@ proc merge_table {tbl_name verbose} {
#@     set tbl_struct [db3inc eval "pragma table_info($tbl_name)"]
#@     set tbl_struct0 [db3 eval "pragma table_info($tbl_name)"] ;# same name table in original sql_file
#@     set max_lib_no0 [get_max_lib_no $tbl_struct0];# max lib# in sql_file
#@     set cols00 [print_column_names_for_table "" $tbl_struct0 "" ","]
#@     set cols00 [lindex $cols00 1];	# all column name list in original sql_file
#@ 
#@     if {[regexp {.+ lib[0-9]+ .+} $tbl_struct]} { ;# if sql_file2 has same name table with lib1,lib2,..., merge it to $sql_file with new columns added 
#@ 	set max_lib_no [get_max_lib_no $tbl_struct] ;# max lib# in sql_file2
#@ 	set cols [print_column_names_for_table "" $tbl_struct "" ","]
#@ 	#set col_num [lindex $cols 0]
#@ 	set cols [lindex $cols 1]
#@ 	set cols0 $cols ;# all the column names in tbl_name in sql_file2
#@ 	#left join
#@ 	set cols [populate_lib_number_list $max_lib_no0 $max_lib_no "inc_db3.$tbl_name"];# inc_db3.$tbl_name. to lib2,lib3,...
#@ 	set cols00 [populate_column_list $cols00 "main.$tbl_name"]     ;# prefix main.$tbl_name to column names
#@ 	set col_names_selected [concat "$cols00" $cols]
#@ 	set on_cond [join_on_cond $tbl_name $cols0] ;# join on condition
#@ 	db3 eval "CREATE TABLE ${tbl_name}_left_join AS SELECT $col_names_selected from main.$tbl_name LEFT JOIN inc_db3.$tbl_name on $on_cond"
#@ 	#right join 
#@ 	regsub -all ",lib1,.+" $cols0 ",lib1," cols0 ;# remove lib2,lib3,...
#@ 	set cols0 [populate_column_list $cols0 "inc_db3.$tbl_name"]     ;# prefix inc_db3.$tbl_name to column names
#@ 	set cols1 [populate_lib_number_list 1 $max_lib_no0 "main.$tbl_name"];# $tbl_name.lib2, $tbl_name.lib3, ...
#@ 	set cols1 [concat $cols1 ",$cols"]
#@ 	set col_names_selected [concat $cols0 $cols1]
#@ 	db3 eval "CREATE TABLE ${tbl_name}_right_join AS SELECT $col_names_selected from inc_db3.$tbl_name LEFT JOIN main.$tbl_name on $on_cond"
#@ 	db3 eval "drop table if exists ${tbl_name}";# drop original table and use union table below instead
#@ 	#union left and right, i.e. merge original and incremental tables
#@ 	db3 eval "CREATE TABLE $tbl_name AS SELECT * FROM ${tbl_name}_left_join UNION SELECT * FROM ${tbl_name}_right_join"
#@ 	#populate records by value from lib1 
#@ 	set set_where [update_set_where $max_lib_no0]
#@ 	db3 eval "UPDATE $tbl_name SET $set_where AND lib1 IS NOT NULL" ;# case 1: add set_attribute to autofix.tcl
#@ 	db3 eval "drop table if exists ${tbl_name}_left_join"
#@ 	db3 eval "drop table if exists ${tbl_name}_right_join"
#@     } elseif {$tbl_name == "libchk201_library_list"} { ;# for libchk201 join/union with no duplciate lib_name
#@ 	set max_logic_num0 [get_max_lib_no_libchk201 "Logic\#" db3]    ;# max logic lib# in sql_file
#@ 	set max_logic_num  [get_max_lib_no_libchk201 "Logic\#" db3inc] ;# max logic lib# in sql_file2
#@ 	array set rep_lib_nos [map_replaced_lib_numbers $max_logic_num]  ;# replaced lib#'s map from incr to original LIBCHK-201
#@ 	set len [string length $max_logic_num0]
#@ 	set lib_num [format "%0*d" $len 1];# e.g. change Logic#1 to Logic#01
#@ 	db3inc eval "UPDATE $tbl_name SET lib_no = 'Logic\#$lib_num' WHERE lib_no = 'Logic\#1'"
#@ 	for {set i 2} {$i <= $max_logic_num} {incr i} { ;# increment lib_no's in db3inc
#@ 	    set lib_num [expr $max_logic_num0 + $i - 1]
#@ 	    if [info exists rep_lib_nos($i)] {# if replaced lib, take the original lib_num
#@ 		set lib_num $rep_lib_nos($i)
#@ 	    }
#@ 	    set lib_num [format "%0*d" $len $lib_num];# e.g. change Logic#2 to Logic#02
#@ 	    db3inc eval "UPDATE $tbl_name SET lib_no = 'Logic\#$lib_num' WHERE lib_no = 'Logic\#$i'"
#@ 	}
#@ 	union_table $tbl_name
#@ 	if {$verbose == 1} { 
#@ 	    print_table $tbl_name
#@ 	}
#@     } else {  ;# if sql_file2 has same name table without lib1,lib2,..., merge the records to $sql_file
#@ 	union_table $tbl_name
#@     }
#@     # remove empty table
#@     if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {
#@ 	db3 eval "drop table if exists $tbl_name"
#@     }
#@ }
#@ define_proc_attributes merge_table -hidden
#@ 					
#@ # update LIBCHK-210, LIBCHK-211
#@ proc merge_table2 {tbl_name} {
#@     set tbl_struct [db3inc eval "pragma table_info($tbl_name)"]
#@     set tbl_struct0 [db3 eval "pragma table_info($tbl_name)"] ;# same name table in original sql_file
#@ 
#@     if {$tbl_name == "libchk210_missing_logic_cells"} { ;# update separately
#@ 	# remove duplicate cells from LIBCHK-210 if LIBCHK-112 exists
#@ 	set tbl_exist [db3inc eval "pragma table_info(libchk112_same_name_cells)"]
#@ 	if {[llength $tbl_exist] > 0} { # if LIBCHK-112 exists in db3inc
#@ 	    set dup_cells0 [db3inc eval " SELECT cell_name FROM libchk112_same_name_cells "]
#@ 	    #insert quote to each cell_name => 'cell_name' for sql
#@ 	    set dup_cells ""
#@ 	    foreach cell_name $dup_cells0 {lappend dup_cells "'$cell_name'"}
#@ 	    set where_in [join $dup_cells ","]
#@ 	    db3 eval "DELETE FROM $tbl_name WHERE cell_name IN ($where_in)"
#@ 	}
#@ 
#@ 	variable added_phys_libs
#@ 	variable removed_phys_libs
#@ 	if {[llength $added_phys_libs] > 0} {# frame added
#@ 	    union_table $tbl_name
#@ 	}
#@ 	if {[info exists removed_phys_libs] && [llength $removed_phys_libs] > 0 && [llength $tbl_struct0] > 0} {# frame removed
#@ 	    set extra_phys_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@ 	    if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {# if updated LIBCHK-210 is empty, then missing phys cells => final LIBCHK-211
#@ 		puts "Warning: Original db3 has LIBCHK-210. Need re-xcheck for libchk211_missing_phys_cells after removing frame files $removed_phys_libs."
#@ 	    }
#@ 	}
#@     } elseif {$tbl_name == "libchk211_missing_phys_cells"} { ;# update separately
#@ 	variable added_phys_libs
#@ 	variable missing_phys_cells
#@ 	set extra_db_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@ 	set missing_phys_cells $extra_db_cells;# scenario 2.2
#@ 	if {[llength $tbl_struct] > 0 && [llength $added_phys_libs] > 0} {# frame added, Update autofix.tcl
#@ 	    set new_phys_cells [db3inc eval " SELECT cell_name FROM $tbl_name "]
#@ 	    # Xcheck cells in new frame vs. extra cells in dbs
#@ 	    # if $extra_db_cells > new_phys_cells, update LIBCHK-211 by removing records where cells in new frame
#@ 	    if {[llength $extra_db_cells] > [llength $new_phys_cells]} {# update autofix.tcl: change create_dummy_physical_cell to remove_physical_lib_cell on $new_phys_cells
#@ 		db3 eval "ALTER TABLE $tbl_name RENAME TO ${tbl_name}_old"
#@ 		#insert quote to each cell_name => 'cell_name' for sql
#@ 		set new_phys_cells2 ""
#@ 		foreach cell_name $new_phys_cells {lappend new_phys_cells2 "'$cell_name'"}
#@ 		set where_in [join $new_phys_cells2 ","]
#@ 		db3 eval "INSERT INTO $tbl_name SELECT * FROM ${tbl_name}_old WHERE cell_name NOT IN ($where_in)"
#@ 	    } elseif {[llength $tbl_struct] > 0} { # updated LIBCHK-211 is empty, then remaining cells = missing logic cells = incr LIBCHK-210 with extra db cells removed 
#@ 		db3 eval "drop table if exists $tbl_name"
#@ 		#insert quote to each cell_name => 'cell_name' for sql
#@ 		set extra_db_cells2 ""
#@ 		foreach cell_name $extra_db_cells {lappend extra_db_cells2 "'$cell_name'"}
#@ 		set where_in [join $extra_db_cells2 ","]
#@ 		db3 eval "INSERT INTO $tbl_name SELECT * FROM inc_db3.libchk210_missing_logic_cells WHERE cell_name NOT IN ($where_in)"
#@ 	    }
#@ 	    # get intersection of extra_db_cells and new_phys_cells for autofix
#@ 	    # scenario 3.1
#@ 	    variable flib_extra_cells
#@ 	    variable flib_missing_cells
#@ 	    set flib_extra_cells [list_intersect $extra_db_cells $new_phys_cells]
#@ 	    set flib_missing_cells [list_exclude $extra_db_cells $new_phys_cells]
#@ 	}
#@ 	if {[info exists removed_phys_libs] && [llength $removed_phys_libs] > 0} {# frame removed
#@ 	    #Get extra_db_cells from old LIBCHK-211
#@ 	    #Get removed cells in removed frame? 
#@ 	    #Add records where cell in removed frame into old LIBCHK-211 
#@ 	    puts "Warning: Original db3 has LIBCHK-211. Need re-xcheck for libchk211_missing_phys_cells after removing frame files $removed_phys_libs."
#@ 	}				
#@     }
#@ }
#@ define_proc_attributes merge_table2 -hidden
#@ 
#@ proc union_table {tbl_name} {
#@     db3 eval "CREATE TABLE ${tbl_name}_union AS SELECT * FROM $tbl_name UNION SELECT * FROM inc_db3.$tbl_name"
#@     db3 eval "drop table if exists $tbl_name"
#@     db3 eval "ALTER TABLE ${tbl_name}_union RENAME TO $tbl_name"
#@ }
#@ define_proc_attributes union_table -hidden
#@ 
#@ proc print_table {tbl_name} {			
#@     set tbl_struct [db3 eval "pragma table_info($tbl_name)"]
#@     set cols [print_column_names_for_table "" $tbl_struct "" ","]
#@     set num_cols [lindex $cols 0]
#@     set arr1 [db3 eval "select * from $tbl_name"]
#@     print_column_names_for_table stdout $tbl_struct "" "\t"
#@     print_records_for_table stdout $arr1 $num_cols "\t"
#@ }
#@ define_proc_attributes print_table -hidden
#@ 
#@ # map library number e.g. lib1 to library_name
#@ proc map_lib_no_to_name {lib_no_and_names} {
#@     array set arr ""
#@     set num_libs [llength $lib_no_and_names]
#@     for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	set lib_no   [ lindex $lib_no_and_names $i ]
#@ 	set lib_name [ lindex $lib_no_and_names [expr $i+1] ]
#@ 	regsub -all "Logic\#" $lib_no "lib" lib_no
#@ 	set arr($lib_no) $lib_name
#@ 	# lib01 and lib1 should both map to lib_name
#@ 	if [regexp {^lib[0-9]+} $lib_no] {# if lib#
#@ 	    regsub "^lib(0+)" $lib_no "lib" lib_no1;# remove leading 0's
#@ 	    if {[string compare $lib_no1 $lib_no] != 0} {# e.g. lib01 vs. lib1
#@ 		set arr($lib_no1) $lib_name
#@ 	    }
#@ 	}
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_lib_no_to_name -hidden
#@ 
#@ # map library_name to lib_no e.g. lib1
#@ proc map_lib_name_to_no {lib_no_and_names} {
#@     array set arr ""
#@     set num_libs [llength $lib_no_and_names];# 2x number of libs
#@     for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	set lib_no   [ lindex $lib_no_and_names $i ]
#@ 	set lib_name [ lindex $lib_no_and_names [expr $i+1] ]
#@ 	regsub -all "Logic\#" $lib_no "lib" lib_no
#@ 	set arr($lib_name) $lib_no
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_lib_name_to_no -hidden
#@ 
#@ # remove records associated with removed libs from original table e.g. libchk213_mismatched_pins
#@ proc remove_records_from_table {rm_libs tbl_name} {
#@     variable lib_name2nos
#@     set where_cond ""
#@     set i 0
#@     # compose "WHERE pin_type_direction LIKE %(Physi#1)"
#@     foreach lib_name $rm_libs {
#@ 	if [regexp {^lib[0-9]+} $lib_name] { continue }
#@ 	# if phys libs, compose where clause
#@ 	if {$i > 0} { lappend where_cond "OR" }
#@ 	set where_cond [concat "pin_type_direction LIKE \'%($lib_name2nos($lib_name))%\' "]
#@ 	incr i
#@     }
#@     if {$i > 0} {			# if phys lib removed
#@ 	db3 eval "DELETE FROM $tbl_name WHERE $where_cond"
#@ 	if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {# remove empty table
#@ 	    db3 eval "drop table if exists $tbl_name"
#@ 	}
#@     }
#@ }
#@ define_proc_attributes remove_records_from_table -hidden
#@  
#@ # compose where clause to skip records where lib_name = libi, for all tables
#@ proc remove_lib_where {exclude_cols} {
#@     variable lib_no2names0
#@     variable db_removed
#@     variable frame_removed
#@     set db_removed 0
#@     set frame_removed 0
#@ 
#@     set where_cond "where"
#@     set i 0
#@     foreach lib_no $exclude_cols {
#@ 	if {$i > 0} {
#@ 	    lappend where_cond "and"
#@ 	}
#@ 	if {[regexp {^lib[0-9]+} $lib_no] && [info exists lib_no2names0($lib_no)]} { ;# e.g. $lib_no is lib1
#@ 	    lappend where_cond "lib_name!='$lib_no2names0($lib_no)'" 
#@ 	    set db_removed 1
#@ 	} else {
#@ 	    lappend where_cond "lib_name!='$lib_no'";# physical lib name
#@ 	    set frame_removed 1
#@ 	}
#@ 	incr i
#@     }
#@     return $where_cond
#@ }
#@ define_proc_attributes remove_lib_where -hidden
#@ 
#@ # compose where clause to skip records with consistent values: where lib2!=lib1 or lib3!=lib1
#@ proc neq_val_where {col_names exclude_cols} {
#@     set where_cond ""
#@     if {[llength $exclude_cols] > 0 && [regexp {,lib[0-9]+} $col_names] >= 0} {
#@     set col_name_lst [split $col_names ,]
#@     set where_cond "where"
#@     set lib_no 0
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name]} { ;# lib1, lib2, ...
#@ 	    if {$lib_no == 0} {
#@ 		set lib1 $col_name
#@ 	    } elseif {$lib_no > 1} {
#@ 		lappend where_cond "or"
#@ 		lappend where_cond "$col_name!=$lib1"
#@ 	    } else {
#@ 		lappend where_cond "$col_name!=$lib1"
#@ 	    }
#@ 	    incr lib_no
#@ 	}
#@     }
#@     if {$lib_no <= 1} {
#@ 	set where_cond ""
#@     }
#@   }
#@   return $where_cond
#@ }
#@ define_proc_attributes neq_val_where -hidden
#@ 
#@ # compose where clause for consistent values: where lib2=lib1 and lib3=lib1
#@ proc eq_val_where {col_names exclude_cols {value ""}} {
#@     set where_cond ""
#@     if {[llength $exclude_cols] > 0 && [regexp {,lib[0-9]+} $col_names] >= 0} {
#@     set col_name_lst [split $col_names ,]
#@     set where_cond "where"
#@     set lib_no 0
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name]} { ;# lib1, lib2, ...
#@ 	    if {$lib_no == 0} {
#@ 		set lib1 $col_name
#@ 	    } elseif {$lib_no > 1} {
#@ 		lappend where_cond "and"
#@ 		lappend where_cond "$col_name=$lib1"
#@ 	    } else {
#@ 		lappend where_cond "$col_name=$lib1"
#@ 	    }
#@ 	    incr lib_no
#@ 	}
#@     }	
#@     if {$value != ""} {
#@ 	lappend where_cond "and"
#@ 	lappend where_cond "$lib1=$value"
#@     }
#@     if {$lib_no <= 1} {
#@ 	set where_cond ""
#@     }
#@   }
#@   return $where_cond
#@ }
#@ define_proc_attributes eq_val_where -hidden
#@ 
#@ # compose join on condition: main.$tbl_name.$col_name=inc_db3.$tbl_name.$col_name
#@ proc join_on_cond {tbl_name col_names} {
#@     set col_name_lst [split $col_names ,]
#@     #get all columns other than lib1, lib2, ...
#@     set on_cond ""
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name] == 0} { ;# if a key column name other than lib1, ...
#@ 	    #lappend col_name_lst1 $col_name
#@ 	    if {[llength $on_cond] > 0} {
#@ 		lappend on_cond "AND"
#@ 	    }
#@ 	    lappend on_cond "main.$tbl_name.$col_name=inc_db3.$tbl_name.$col_name"
#@ 	}
#@     }
#@     return $on_cond
#@ }
#@ define_proc_attributes join_on_cond -hidden
#@ 
#@ # get max lib number from tbl_struct returned from [pragma table_info($tbl_name)]
#@ proc get_max_lib_no {tbl_struct} {
#@     set cols [lindex [print_column_names_for_table "" $tbl_struct "" ","] 1]
#@     set max_lib_no [string range $cols [string last lib $cols]+3 [string length $cols]-1]
#@     return $max_lib_no
#@ }
#@ define_proc_attributes get_max_lib_no -hidden
#@ 
#@ # get max Logic#/Physi# number from libchk201_library_list
#@ # lib_type = 'Logic#' or 'Physi#'
#@ proc get_max_lib_no_libchk201 {lib_type db3} {
#@     set lib_nums [$db3 eval "select lib_no from 'libchk201_library_list' where lib_no like '${lib_type}%'"]
#@     set max_lib_no [lindex $lib_nums [expr [llength $lib_nums]-1]]
#@     return [string range $max_lib_no 6 end];# max lib_no
#@ }
#@ define_proc_attributes get_max_lib_no_libchk201 -hidden
#@ 
#@ # prefix inc_db3.$tbl_name to each column names
#@ proc populate_column_list {col_names prefix} {
#@     set col_name_lst [split $col_names ,]
#@     #get all columns other than lib1, lib2, ...
#@     set key_cols ""
#@     foreach col_name $col_name_lst {
#@ 	if {$col_name != ""} { ;# if a valid column name
#@ 	    lappend key_cols "$prefix.$col_name,"
#@ 	}
#@     }
#@     return $key_cols
#@ }
#@ define_proc_attributes populate_column_list -hidden
#@ 
#@ # compose table names, prefix = main.$tbl_name or inc_db3.$tbl_name
#@ proc populate_lib_number_list {max_lib_no max_lib_no2 prefix} {
#@     variable lib_name2nos
#@     variable lib_no2names
#@     set lib_nos ""
#@     set lib_name ""
#@     set ndx $max_lib_no
#@     for {set i 2} {$i <= $max_lib_no2} {incr i} {
#@       lappend lib_nos $prefix.lib$i
#@       if {[string range $prefix 0 6] == "inc_db3"} { # if attach, i.e. inc_db3
#@ 	# get new lib index for libs in db3inc: $max_lib_no+1,2,... for newly added and mapped lib index in db3 via lib_name
#@ 	if [info exists lib_no2names(lib$i)] {
#@ 	    set lib_name $lib_no2names(lib$i)
#@ 	}
#@ 	if {$lib_name != "" && [info exists lib_name2nos($lib_name)]} {# if same lib is found in db3, replace it by new one
#@ 	  set lib_no $lib_name2nos($lib_name)
#@ 	} else {
#@ 	  incr ndx
#@ 	  set lib_no lib$ndx
#@ 	}
#@ 	lappend lib_nos "as"
#@ 	lappend lib_nos $lib_no
#@       }
#@       if {$i < $max_lib_no2} {
#@ 	set lib_nos [concat $lib_nos,]
#@       }
#@     }
#@     return $lib_nos
#@ }
#@ define_proc_attributes populate_lib_number_list -hidden
#@ 
#@ # get map of lib numbers from incr to original LIBCHK-201 for the replaced libraries
#@ proc map_replaced_lib_numbers {max_lib_no2} {
#@     array set arr ""
#@     variable lib_name2nos;		# from db3
#@     variable lib_no2names;		# from inc_db3
#@     variable removed_dbs
#@     set lib_name ""
#@     for {set i 2} {$i <= $max_lib_no2} {incr i} {
#@ 	if [info exists lib_no2names(lib$i)] {
#@ 	    set lib_name $lib_no2names(lib$i)
#@ 	    # if same lib is found in both db3 and -remove_libs, replace it by new one
#@ 	    if {[info exists lib_name2nos($lib_name)] && [info exists removed_dbs] && [lsearch $removed_dbs $lib_name2nos($lib_name)] >= 0} {
#@ 		set lib_no [string range $lib_name2nos($lib_name) 3 end];# strip out prefix lib to extract the number, e.g. lib2
#@ 		set arr($i) $lib_no
#@ 	    }
#@ 	}
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_replaced_lib_numbers -hidden
#@ 
#@ # compose set where string e.g. "SET lib2 = lib1, lib3 = lib1 WHERE lib2 is null" for UPDATE $tbl_name
#@ proc update_set_where {max_lib_no} {
#@     set set_values ""
#@     set where_cond ""
#@     for {set i 2} {$i <= $max_lib_no} {incr i} {
#@       lappend set_values "lib$i=lib1"
#@ 	# lib$ IS NULL
#@       lappend where_cond "lib$i"
#@       lappend where_cond "IS"
#@       lappend where_cond "NULL"
#@       if {$i < $max_lib_no} {
#@ 	append set_values ,
#@ 	lappend where_cond "AND"
#@       }
#@     }
#@     return [concat $set_values "WHERE" $where_cond]
#@ }
#@ define_proc_attributes update_set_where -hidden
#@ 
#@ # Get extra db cells from incr LIBCHK-310 $tbl_name (those missing on lib1)
#@ # Scenario 2.1: check_library -logic_vs_physical with dbs added 
#@ # Ex: extra_cells = "FOOT2X16_HVT FOOT2X2_HVT", llength = 0 if empty
#@ proc get_extra_db_cells_dbs_added {tbl_name} {
#@     variable extra_db_cells_dbs_added
#@     set extra_db_cells_dbs_added ""
#@     set tbl_exist [db3inc eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set extra_db_cells_dbs_added [db3inc eval " SELECT cell_name from $tbl_name WHERE lib1='missing' "]
#@     }
#@     return $extra_db_cells_dbs_added
#@ }
#@ define_proc_attributes get_extra_db_cells_dbs_added -hidden
#@ 
#@ # Get extra cells from updated LIBCHK-310 (those missing cells in all non-removed dbs)
#@ # Scenario 2.2: check_library -logic_vs_physical with dbs removed
#@ proc get_extra_db_cells_dbs_removed {tbl_name cols rm_libs} {
#@     variable extra_db_cells_dbs_removed
#@     set where_eq_cond [eq_val_where $cols $rm_libs "missing"]
#@     set extra_db_cells_dbs_removed [db3 eval " SELECT cell_name FROM $tbl_name $where_eq_cond "] 
#@     return $extra_db_cells_dbs_removed
#@ }
#@ define_proc_attributes get_extra_db_cells_dbs_removed -hidden
#@ 
#@ # Get extra cells in dbs: from old LIBCHK-211
#@ # Get extra cells in frame: from old LIBCHK-210
#@ # Get cells in new frame from incr LIBCHK-210 with _rpt_phys = 1
#@ # Scenario 3.1: check_library -logic_vs_physical with frame added 
#@ # Scenario 3.2: check_library -logic_vs_physical with frame removed 
#@ proc get_extra_cells {tbl_name} {
#@     set extra_cells ""
#@     set tbl_exist [db3 eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set extra_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@     }
#@     return $extra_cells
#@ }
#@ define_proc_attributes get_extra_cells -hidden
#@ 
#@ # Get added, removed or replaced phys/logic lib names by comparing original and incr LIBCHK-201 tables
#@ # lib_type = 'Logic#' or 'Physi#', update_type = 1 if added, -1 if removed, or 2 if replaced
#@ # replaced dbs include lib1 that is the reference for incr check
#@ # return list of updated lib names
#@ proc get_updated_libs {lib_type update_type} {
#@     set lib_names0 [db3    eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@     set lib_names2 [db3inc eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@ 
#@     set lib_names "" ;# updated lib name list
#@     if {$update_type == -1} {
#@       # find lib name in db3 from db3inc
#@       foreach lib_name $lib_names0 {
#@ 	set lib_exist [lsearch $lib_names2 $lib_name]
#@ 	# removed
#@ 	if {$lib_exist < 0} {
#@ 	    lappend lib_names $lib_name
#@ 	}
#@       }
#@     } else {
#@       # find lib name in db3inc from db3
#@       foreach lib_name $lib_names2 {
#@ 	set lib_exist [lsearch $lib_names0 $lib_name]
#@ 	# added or replaced
#@ 	if {($update_type == 1 && $lib_exist < 0) || ($update_type == 2 && $lib_exist >= 0)} {
#@ 	    lappend lib_names $lib_name
#@ 	}
#@       }
#@     }
#@ 
#@     return $lib_names
#@ }
#@ define_proc_attributes get_updated_libs -hidden
#@ 
#@ # Get removed phys/logic lib names from -remove_lib option
#@ # lib_type = 'Logic#' or 'Physi#'
#@ # return list of updated lib names
#@ proc get_removed_libs {lib_type rm_libs} {
#@     set lib_names "" ;# removed lib name list
#@     foreach one_lib $rm_libs {
#@ 	if {$lib_type == "Logic#" && [regexp {^lib[0-9]+} $one_lib] && [info exists lib_no2names0($one_lib)]} { ;# e.g. $one_lib is lib1
#@ 	    lappend lib_names $lib_no2names0($one_lib)
#@ 	} else {
#@ 	    lappend lib_names $one_lib
#@ 	}
#@     }
#@     return $lib_names
#@ }
#@ define_proc_attributes get_removed_libs -hidden
#@ 
#@ # after deleting records stored in new $tbl_name (libchk311, libchk321 and libchk322), the remaining records in the old table 
#@ # contain data that have consistent values across logic libs which will be used to remove associated lines from autofix0.tcl
#@ proc get_removed_records {tbl_name} {
#@     set cell_attr_removed ""
#@     variable removed_lines
#@     set removed_lines ""
#@     set num_cols 3
#@     if {$tbl_name == "libchk311_mismatched_cells_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, attribute FROM ${tbl_name}_old "]
#@ 	set num_cols 2
#@     } elseif {$tbl_name == "libchk321_mismatched_pins_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, pin_name, attribute FROM ${tbl_name}_old "]
#@     } elseif {$tbl_name == "libchk322_mismatched_pg_pins_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, pg_pin, attribute FROM ${tbl_name}_old "]
#@     }
#@     # Compose pattern (e.g. '/cell_name\] -name attribute') for sed to delete from autofix0.tcl
#@     set sz [llength $cell_attr_removed]
#@     for {set i 0} {$i < $sz} {incr i $num_cols} {
#@ 	set cell1 [lindex $cell_attr_removed $i]   
#@ 	set attr [lindex $cell_attr_removed [expr $i+$num_cols-1]]   
#@ 	if {$num_cols == 2} {		# libchk311_mismatched_cells_slg
#@ 	    set cell_ptn "\\/$cell1\] -name $attr"
#@ 	} elseif {$tbl_name == "libchk321_mismatched_pins_slg"} {
#@ 	    set pin1 [lindex $cell_attr_removed [expr $i+1]];#    pin
#@ 	    set cell_ptn "\\/$cell1\\/$pin1\] -name $attr"
#@ 	} else {			# libchk322_mismatched_pg_pins_slg
#@ 	    # non-existent for now
#@ 	    set pin1 [lindex $cell_attr_removed [expr $i+1]];#    pg_pin
#@ 	    set cell_ptn "\\/$cell1\] -filter name==$pin1"
#@ 	    set pg_attr "pg_pin $attr";	# set_attribute $pg_pin %s %s
#@ 	}
#@ 	lappend removed_lines $cell_ptn
#@ 	if {$tbl_name == "libchk322_mismatched_pg_pins_slg"} {
#@ 	    lappend removed_lines $pg_attr
#@ 	}
#@     }
#@ 
#@     return $removed_lines
#@ }
#@ define_proc_attributes get_removed_records -hidden
#@ 
#@ # if $tbl_name exists in db3, return $tbl_exist not empty
#@ proc table_exists {sql_file tbl_name} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     set tbl_exist [db3 eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set flib_sql_list $tbl_exist
#@     } else {
#@ 	set flib_sql_list ""
#@     }
#@     db3 close
#@     return $tbl_exist
#@ }
#@ define_proc_attributes table_exists -hidden
#@ 
#@ # List operations
#@ # lista*listb
#@ proc list_intersect { lista listb } {
#@     set result {}
#@     foreach elem $listb {
#@ 	if { [lsearch -exact $lista $elem] != -1 } {
#@             lappend result $elem
#@ 	}
#@     }
#@     return $result
#@ }
#@ define_proc_attributes list_intersect -hidden
#@ 
#@ # lista-listb
#@ proc list_exclude { lista listb } {
#@     set result {}
#@     foreach elem $lista {
#@ 	if { [lsearch -exact $listb $elem] == -1 } {
#@             lappend result $elem
#@ 	}
#@     }
#@     return $result
#@ }
#@ define_proc_attributes list_exclude -hidden
#@ 
#@ # update autofix.tcl 
#@ # Scenario 1.1(add corner dbs): append set_attribute lines from autofix1.tcl into autofix0.tcl
#@ # Scenario 2.1(add corner dbs): concat missing_cells, if any, with extra_db_cells_dbs_added for create_dummy_physical_cell in autofix1.tcl and merge into autofix0.tcl
#@ #                               append set_attribute lines for the new extra cells into autofix0.tcl 
#@ # Scenario 3.1(add frame): extra cells in dbs: Update autofix0.tcl in $missing_cells for create_dummy_physical_cell and $extra_cells for remove_physical_lib_cell
#@ #                          extra cells in frame: No change as no db cells are added
#@ proc update_autofix_tcl {sql_file sql_file2} {
#@     # get autofix*.tcl file names
#@     set root_name  [file rootname $sql_file]
#@     set root_name2 [file rootname $sql_file2]
#@     set tcl_name  ${root_name}.tcl;	# autofix0.tcl 
#@     set tcl_name2 ${root_name2}.tcl;	# autofix1.tcl 
#@     
#@     if ![file exists $tcl_name] {	# if there is no original autofix0.tcl generated
#@ 	return
#@     }
#@ 
#@     set extra_db_cells_vs_phys [get_extra_cells "libchk211_missing_phys_cells"];# extra db cells from old libchk211 in autofix0.tc
#@ 
#@     variable db_removed
#@     variable frame_removed
#@     variable removed_phys_libs
#@     variable removed_lines;		# from libchk311, libchk321 and libchk322
#@     variable extra_db_cells_dbs_removed;	# from LIBCHK-310
#@     
#@     if {[info exists removed_lines] && $db_removed == 1} {# if dbs removed	
#@ 	# Scenario 1.2: remove lines from autofix0.tcl matching $removed_lines from libchk311, libchk321 and libchk322
#@ 	foreach one_line $removed_lines {
#@ 	    exec sed -i "/$one_line/d" $tcl_name;# removed lines that have consistent values across dbs after db_removed
#@ 	}
#@ 	# Scenario 2.2: check_library -logic_vs_physical 
#@ 	if [info exists missing_phys_cells] {
#@ 	    # extra_db_cells_dbs_removed, missing_phys_cells
#@ 	    set updated_missing_cells [list_exclude $missing_phys_cells $extra_db_cells_dbs_removed]
#@ 	    set updated_extra_cells [list_intersect $missing_phys_cells $extra_db_cells_dbs_removed]
#@ 	    # edit autofix0.tcl in-place
#@ 	    exec sed -i 's/set missing_cells \".*\"/set missing_cells \"$updated_missing_cells\"/' $tcl_name
#@ 	    exec sed -i 's/set extra_cells \".*\"/set extra_cells \"$updated_extra_cells\"/' $tcl_name
#@ 	}
#@     }
#@ 
#@     if {[info exists frame_removed] && $frame_removed == 1} {# if frame removed	
#@ 	# Scenario 3.2, need re-xcheck if LIBCHK-210 or LIBCHK-211 exists.
#@ 	# else
#@ 	# removed_phys_libs
#@ 	set line_nums "";		# line number range to delete
#@ 	set line1 [exec grep -n "Auto fix script for library" $tcl_name];# get physical lib name with line number
#@ 	regsub -all "\# Auto fix script for library " $line1 "" line1
#@ 	set linenum_to_libname [split $line1 :\n]
#@ 	set num_libs [llength $linenum_to_libname]
#@ 	for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	    set libname [lindex $linenum_to_libname [expr $i+1]]
#@ 	    if { [lsearch -exact $removed_phys_libs $libname] != -1 } {# if libname is in removed list
#@ 		set line_num [lindex $linenum_to_libname $i]
#@ 		lappend line_nums $line_num
#@ 		set i2 [expr $i+2]
#@ 		if {$i2 < $num_libs} {
#@ 		    set line_num2 [lindex $linenum_to_libname $i2]
#@ 		    incr line_num2 -1
#@ 		    lappend line_nums $line_num2
#@ 		}
#@ 	    }
#@ 	}				
#@ 	# delete lines associated with the physical lib removed
#@ 	set num_libs_removed [llength $line_nums]
#@ 	for {set i 0} {$i < $num_libs_removed} {incr i 2} {
#@ 	    set line_num1 [lindex $line_nums $i]
#@ 	    set line_num2 [lindex $line_nums [expr $i+1]]
#@ 	    if {[expr $i+1] < $num_libs_removed} {
#@ 		exec sed -i "$line_num1,${line_num2}d" $tcl_name
#@ 	    } else {
#@ 		exec sed -i "$line_num1,\$d" $tcl_name
#@ 	    }
#@ 	}
#@ 	if {[file size $tcl_name] == 0} {
#@ 	    exec rm -rf $tcl_name;	# remove $tcl_name if empty
#@ 	}
#@     }
#@ 
#@     if ![file exists $tcl_name2] {	# if there is no autofix1.tcl generated
#@ 	return
#@     }
#@ 
#@     # get extra cells
#@     set extra_db_cells_exist 0
#@     set extra_db_cells_dbs_added [get_extra_db_cells_dbs_added "libchk310_missing_cells_slg"]
#@     if [llength $extra_db_cells_dbs_added] {
#@ 	set extra_db_cells_exist 1 
#@     }
#@     set file_id [open $tcl_name a+];	# open autofix0.tcl and append lines from autofix1.tcl
#@     # update tcl_name (autofix0.tcl)
#@     # scenario 3.1
#@     if [llength $extra_db_cells_vs_phys] {
#@ 	set missing_cells0 [exec grep missing_cells $tcl_name]
#@ 	set extra_cells0 [exec grep extra_cells $tcl_name]
#@ 	# edit autofix0.tcl in-place
#@ 	exec sed -i 's/$missing_cells0/$flib_missing_cells/' $tcl_name
#@ 	exec sed -i 's/$extra_cells0/$flib_extra_cells/' $tcl_name
#@     }
#@ 
#@     # read and process tcl_name2 and merge output to tcl_name
#@     set file_id2 [open $tcl_name2 r]
#@     set blk_tag 0;				# identifier for autofix block
#@     while {[gets $file_id2 line] >= 0} {
#@ 	if {[regexp {^\# Cell attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# Pin attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# PG pin attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# Cells to be removed from physical libraries} $line] >= 0} {# xcheck starts
#@ 	    set blk_tag 2
#@ 	} elseif {[regexp {^\# Cells to be removed from logic libraries} $line] >= 0} {
#@ 	    set blk_tag 3
#@ 	} elseif {[regexp {^\# Cells to be added in physical libraries} $line] >= 0} {# missing_cells; create_dummy_physical_cell
#@ 	    set blk_tag 4
#@ #	} elseif {[regexp {^\# Cells to be added in logic libraries} $line] >= 0} {
#@ #	    set blk_tag 5
#@ 	} elseif {[regexp {^\# PG/pins to be corrected by DB in .+} $line] >= 0} {
#@ 	    set blk_tag 6
#@ 	} elseif {[regexp {^\# PG/pins to be corrected by frame in .+} $line] >= 0} {
#@ 	    set blk_tag 7
#@ 	} elseif {[regexp {^\# Diode cells to be corrected in physical libraries} $line] >= 0} {# $diode_cells
#@ 	    set blk_tag 8
#@ 	} elseif {[regexp {^\# Diode pins to be corrected in physical libraries} $line] >= 0} {
#@ 	    set blk_tag 8
#@ 	} elseif {[regexp {^\# Pins to be added in physical librariess} $line] >= 0} {
#@ 	    set blk_tag 9
#@ 	} elseif {[regexp {^\# Pins to be added in logic librariess} $line] >= 0} {
#@ 	    set blk_tag 10
#@ 	} elseif {[regexp {^\# Pins to be removed from physical librariess} $line] >= 0} {
#@ 	    set blk_tag 11
#@ 	} elseif {[regexp {^\# Pins to be removed from logic librariess} $line] >= 0} {
#@ 	    set blk_tag 12
#@ 	}
#@ 				
#@ 	# append the related block to autofix0.tcl
#@ 	switch -exact $blk_tag {
#@ 	    1 {	# logic lib
#@ 		# append set_attribute lines from autofix1.tcl into autofix0.tcl
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    puts $file_id "$line"
#@ 		}
#@ 	    }
#@ 	    4 { # missing_cells+=extra_db_cells_dbs_added; create_dummy_physical_cell
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    if {[regexp {^set missing_cells .*} $line] >= 0} {
#@ 			#set extra_db_cells_vs_phys [get_extra_cells "libchk211_missing_phys_cells"]
#@ 			if [llength $extra_db_cells_vs_phys] {# if autofix0.tcl has missing_cells, concat new extra cells 
#@ 			    puts $file_id "concat \$missing_cells $extra_db_cells_dbs_added"
#@ 			} else {
#@ 			    puts $file_id "set missing_cells \"$extra_db_cells_dbs_added\""
#@ 			}
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    6 { # PG/pins to be corrected by DB
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    # if $cell1 is in $extra_db_cells_dbs_added, append it in autofix0.tcl
#@ 		    set slash1 [string first '/' $line]
#@ 		    set slash2 [string last '/' $line]
#@ 		    incr slash2 -1
#@ 		    #set_attribute [get_physical_lib_pins */cell1/VDD] port_type power
#@ 		    set cell1 [string range $line $slash1 $slash2]
#@ 		    if { [lsearch -exact $extra_db_cells_dbs_added $cell1] >= 0 } {
#@ 			puts $file_id "$line"
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    8 { # Diode cells 
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		  puts $file_id "$line"
#@ 		  #if {[regexp {^set diode_cells .*} $line] >= 0} {# set diode_cells "diode cell name list"
#@ 		      #puts $file_id {concat $diode_cells $extra_db_cells_dbs_added};# concat diode cells from $extra_db_cells_dbs_added
#@ 		  #}
#@ 		}
#@ 	    }
#@ 	    default { }
#@ 	}
#@     }
#@ 
#@     close $file_id
#@ 
#@ }
#@ define_proc_attributes update_autofix_tcl -hidden
#@ }
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/report_check_library_records.tcl

#@ 
#@ #for read_lib -html	
#@ source ${synopsys_root}/auxx/lc/read_lib_html_msg_list.tcl
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/lc/read_lib_html_msg_list.tcl

#@ ##############################################################################
#@ # message ID and descriptions for read_lib -html
#@ # Rev01. changed LBDB-715 to LBDB-262, STAR 9001225503, jizhan, Aug 17
#@ # Rev02. removed LBDB-825, STAR 9001541784, jizhan, Aug 19
#@ ##############################################################################
#@ set read_lib_ccs_noise_msg {
#@     LBDB-262
#@     LBDB-660
#@     LBDB-706
#@     LBDB-708
#@     LBDB-709
#@     LBDB-710
#@     LBDB-711
#@     LBDB-712
#@     LBDB-713
#@     LBDB-714
#@     LBDB-716
#@     LBDB-717
#@     LBDB-718
#@     LBDB-733
#@     LBDB-734
#@     LBDB-784
#@     LBDB-824
#@     LBDB-858
#@     LBDB-898
#@     LBDB-899
#@     LBDB-908
#@     LBDB-920
#@     LBDB-935
#@     LBDB-936
#@     LBDB-937
#@     LBDB-938
#@     LBDB-939
#@ }
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/lc/read_lib_html_msg_list.tcl

#@ #alias list_commands help
#@ 
#@ if {  [info commands "create_physical_lib"] == "create_physical_lib" } {
#@ # create_physical_lib only exists in lc2_shell, slc_shell don't need to source those script
#@ # You can add a file named LC2_setup.tcl to auxx/LC2/tcl if you want
#@ # some extra initialization separate from the .synopsys files.
#@   lappend auto_path [file join $::synopsys_root auxx LC2 tcl]
#@     if { [file exists [file join $::synopsys_root auxx LC2 tcl LC2_setup.tcl]] } {
#@       source [file join $::synopsys_root auxx LC2 tcl LC2_setup.tcl]
#@     }
#@   if { [file exists [file join $::synopsys_root auxx LC2 tcl report_lib.tcl]] } {
#@ #for report_lib mega command
#@     source [file join $::synopsys_root auxx LC2 tcl report_lib.tcl]
#@   }
#@ 
#@   if { [file exists [file join $::synopsys_root auxx LC2 tcl set_attribute.tcl]] } {
#@ #for report_lib mega command
#@     source [file join $::synopsys_root auxx LC2 tcl set_attribute.tcl]
#@   }
#@ 
#@   if { [file exists [file join $::synopsys_root auxx LC2 tcl lclm_get_lib.tcl]] } {
#@ #for get_lib* mega command
#@     source [file join $::synopsys_root auxx LC2 tcl lclm_get_lib.tcl]
#@   }
#@ }
#@ # Temporary fix for the LMC_HOME variable- set it to an empty string 
#@ 
#@ if { [catch {getenv LMC_HOME } __err ] != 0 } {
#@   setenv LMC_HOME ""
#@ }
#@ 
#@ #
#@ #
#@ #       Site-Specific Variables
#@ #
#@ #       These are the variables that are most commonly changed at a
#@ #       specific site, either upon installation of the Synopsys software,
#@ #       or by specific engineers in their local .synopsys_lc.setup files.
#@ #
#@ #
#@ 
#@ # from the System Variable Group 
#@ set search_path [list . ${synopsys_root}/libraries/syn]
#@ 
#@ # do we need command_log_file ?
#@ set command_log_file $sh_command_log_file
#@ 
#@ set view_command_log_file  "./view_command.log"
#@ 
#@ # from the View Variable group
#@ if { $sh_arch == "hp700" } {
#@    set text_print_command  "lp -d" 
#@ } else {
#@    set text_print_command  "lpr -Plw" 
#@ }
#@ 
#@ 
#@ #
#@ #       System Variable Group:
#@ #
#@ #       These variables are system-wide variables.
#@ #
#@ 
#@ set verbose_messages  "true"
#@ set echo_include_commands  "true"
#@ set suppress_errors  {}
#@ 
#@ # variables pertaining to VHDL library generation 
#@ set vhdllib_timing_mesg   "true"
#@ set vhdllib_timing_xgen   "false"
#@ set vhdllib_timing_checks   "true"
#@ set vhdllib_negative_constraint   "false"
#@ set vhdllib_glitch_handle   "true"
#@ set vhdllib_pulse_handle   "use_vhdllib_glitch_handle"
#@ # /*set vhdllib_architecture   {FTBM, UDSM, FTSM, FTGS, VITAL} */
#@ set vhdllib_architecture   {VITAL}
#@ set vhdllib_tb_compare   0
#@ set vhdllib_tb_x_eq_dontcare   FALSE
#@ set vhdllib_logic_system   "ieee-1164"
#@ set vhdllib_logical_name   ""
#@ 
#@ # variables pertaining to technology library processing 
#@ set read_db_lib_warnings   FALSE
#@ set read_translate_msff    TRUE
#@ set libgen_max_differences   -1
#@ 
#@ set view_on_line_doc_cmd ${synopsys_root}/sold
#@ 
#@ # Aliases for backwards compatibility or other reasons 
#@ #alias groupvar          group_variable
#@ alias free		remove_lib
#@ 
#@ # set filename for logging input file 
#@ set filename_log_file   "lc_filenames.log"  
#@ # whether to delete the filename log after the normal exits 
#@ set exit_delete_filename_log_file   "true"
#@ 
#@ #if { lc_shell_status == 0 } {
#@ #  sh echo {Fatal: System .synopsys_lc.setup file not read properly. Please re-invoke.}
#@ #  sh echo {Note that the init file .synopsy_lc.setup of lc_shell}
#@ #  sh echo {is a subset of the dc_shell init file .synopsys_dc.setup.}
#@ #  sh echo {If a non lc_shell command is encountered in the init file,}
#@ #  sh echo {an error message will be issued and the processing might terminate.}
#@ #  sh echo {Please refer to the Library Compiler reference manual for supported commands.}
#@ #  quit
#@ #}
#@ proc get_legacy_lc_search_path { } {
#@   set exec_path "invalid"
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)] &&  [file exists $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec] } {
#@     set exec_path $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec
#@   }
#@   return $exec_path
#@ }
#@ 
#@ proc get_legacy_lc_synopsys_root { } {
#@   return [file dirname [file dirname [file dirname [file dirname $::legacy_lc_search_path] ] ] ] 
#@ }
#@ 
#@ 
#@ proc valias {v_orig v_alias} {
#@    uplevel 1 "upvar 0 $v_orig $v_alias"
#@ }
#@ 
#@ set legacy_lc_result_path "/tmp"
#@ set legacy_lc_replay_tcl_file "common_shell_command.tcl"
#@ set legacy_lc_search_path [get_legacy_lc_search_path]
#@ valias lc_enable_legacy_library_compiler lc_enable_common_shell_lc
#@ set compile_lib_list ""
#@ set compile_libs_pre_script_path ""
#@ set compile_libs_script_path ""
#@ set compile_libs_log_file_prefix ""
#@ set compile_libs_log_file_suffix ""
#@ set compile_libs_temp_directory ""
#@ set compile_libs_cdpl_log_directory ""
#@ set compile_libs_lic_got false
#@ set compile_libs_var_exported false
#@ set compile_libs_app_opt_exported false
#@ set compile_libs_process_label_exported false
#@ set compile_libs_set_policy_exported false
#@ 
#@ proc legacy_lc_lib2saif { args } {
#@   return [common_shell_write_lib $args]
#@ }
#@ 
#@ 
#@ proc run_legacy_lc_with_echo {tcl_file} {
#@   set chan [open "|$::legacy_lc_search_path -shell lc_shell -r [get_legacy_lc_synopsys_root] -f $tcl_file" r]
#@ # things to do: In debug mode, we want copy the whole output (beginning to end) 
#@ # to a file
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       set log [open $::legacy_lc_result_path/$::legacy_lc_log_path/libra.log w]
#@   }
#@   set echo 0
#@   set ret 0
#@   set firstLine true
#@   while {[gets $chan line] >= 0} {
#@       if {$::lc_keep_legacy_lc_temp_files} { puts $log $line }
#@       if {[string equal -length 7 $line "##@@@##"]} {
#@ 	  set echo [expr ! $echo]
#@ 	  continue;
#@       }
#@       if {$echo} { 
#@         if { $firstLine } {
#@           set firstLine false
#@           continue;
#@         } else { 
#@           if {$line == "1"} {
#@             set ret  1
#@           } elseif {$line == "0"} {
#@             set ret 0
#@           } else {
#@             puts $line 
#@           }
#@         }
#@       }
#@   }
#@   close $chan
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       close $log
#@   }
#@   return $ret;
#@ }
#@ 
#@ proc common_shell_read_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_read_lib_procedure $chan $args
#@   close $chan
#@   echo "Invoking common shell Library Compiler..."
#@   run_legacy_lc_with_echo $tcl_file
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ proc common_shell_add_pg_pin {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   # to use error message in synthesis root as the command is called under the hood
#@   set synopsys ""
#@   set synopsys_syn_root ""
#@   if {[info exists ::env(SYNOPSYS)]} {
#@     set synopsys $::env(SYNOPSYS)
#@   }
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)]} {
#@     set synopsys_syn_root $::env(SYNOPSYS_SYN_ROOT)
#@   }
#@   if {[string compare "$synopsys"  "$synopsys_syn_root"] && [string compare "$synopsys_syn_root" ""]} {
#@     setenv SYNOPSYS  "$synopsys_syn_root"
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_add_pg_pin_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file
#@   common_shell_clean_up
#@   # restore SYNOPSYS enviroment after call synthesis
#@   if {[string compare "$synopsys" ""]} {
#@     setenv SYNOPSYS  "$synopsys"
#@   } else {
#@     unsetenv SYNOPSYS
#@   }
#@ }
#@ 
#@ proc common_shell_write_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file $::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   set ret [run_legacy_lc_with_echo $tcl_file]
#@   common_shell_clean_up
#@   return $ret
#@ }
#@ 
#@ proc common_shell_update_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db   
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file  
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ # create the unique folder under tmp
#@ proc set_folder_var { } {
#@   set fileName [pid]
#@   set ::legacy_lc_log_path [append fileName "_" [clock microseconds]] 
#@   file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path
#@   file mkdir $::legacy_lc_result_path/$::legacy_lc_log_path  
#@ }
#@ 
#@ # export all the vars
#@ proc export_tcl_var { fileName } {
#@ # 2016.03.09 Liping Zhao
#@ # Fix STAR 9001014310. 
#@ # These vars should not be exported.
#@ # 2017.02.09 Liping Zhao
#@ # Fix STAR 90001079691
#@   set filter_attrs [dict create ::errorInfo 1 ::sh_continue_on_error 1 ::sh_command_log_file 1 ::command_log_file 1 ] 
#@     foreach var [info vars ::* ] {
#@       if [array exists $var] {
#@         continue;
#@       }
#@       if [ dict exists $filter_attrs $var ] {
#@         continue;
#@       } elseif [catch { set temp [set $var] } result] {
#@         continue;
#@       }
#@       if { [set $var] != "" } {
#@         puts $fileName "catch \{ set $var \[list \[binary format H* [make_hex [set $var]]\]\] \}"
#@       }  else {
#@         puts $fileName "catch \{ set $var \"\" \}"
#@       }
#@     }
#@     puts $fileName "catch \{ set lc_cpu_allocation \[list \[binary format H* [make_hex $::lc_cpu_allocation]\]\] \}"
#@ 
#@ }
#@ 
#@ # export all the vars for fusion lib related procedure
#@ proc export_flib_tcl_var { fileName } {
#@ # 2016.03.09 Liping Zhao
#@ # Fix STAR 9001014310. 
#@ # These vars should not be exported.
#@ # 2017.02.09 Liping Zhao
#@ # Fix STAR 90001079691
#@ # 2021.07.27 Hongqi Yu
#@ # Use "..." instead of [list ...]
#@   set filter_attrs [dict create ::errorInfo 1 ::sh_continue_on_error 1 ::sh_command_log_file 1 ::command_log_file 1 ] 
#@   # include hidden vars
#@   foreach var [concat [info vars ::* ] [set ::lc_parameter_export_list] ] {
#@     if [array exists $var] {
#@       continue;
#@     }
#@     if [ dict exists $filter_attrs $var ] {
#@       continue;
#@     } elseif [catch { set temp [set $var] } result] {
#@       puts $fileName "#cannot set $var"
#@       continue;
#@     }
#@     if { [set $var] != "" } {
#@       puts $fileName "catch \{ set $var \"\[binary format H* [make_hex [set $var]]\]\" \}"
#@     }  else {
#@       puts $fileName "catch \{ set $var \"\" \}"
#@     }
#@   }
#@ }
#@ 
#@ proc export_app_options { fileName } {
#@   set app_options [ get_app_options -non_default -hidden]
#@   foreach app_option $app_options {
#@     set opt_value [ get_app_option_value -name $app_option ]
#@     if { $opt_value != "" } {
#@       puts $fileName "catch \{ set_app_options -name $app_option -value \"\[binary format H* [make_hex $opt_value]\]\" \}"
#@     } else {
#@       puts $fileName "catch \{ set_app_options -name $app_option -value \"\" \}"
#@     }
#@   }
#@ # hidden app options
#@   set opt_value [ get_app_option_value -name file.tech.use_new_tech_reader ]
#@   if { $opt_value != "" } {
#@     puts $fileName "catch \{ set_app_options -name file.tech.use_new_tech_reader -value \"\[binary format H* [make_hex $opt_value]\]\" \}"
#@   }
#@ }
#@ 
#@ # excuted by libra shell to read the dbs generated by common_shell
#@ proc libra_shell_read_dbs { } {
#@   set dbNames ""
#@   foreach var [glob -nocomplain -directory $::legacy_lc_result_path/$::legacy_lc_log_path *.db] { 
#@     append dbNames " " $var
#@     read_db $var 
#@   }
#@   set ::lc_intermediate_db_files $dbNames
#@ }
#@ 
#@ # display the log file genrated by common_shell in Libra and then remove the unique folder
#@ proc common_shell_clean_up { } {
#@   if { ! $::lc_keep_legacy_lc_temp_files } { 
#@     file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path 
#@   }
#@ }
#@ 
#@ # excuted by libra shell to write out the in-memory dbs
#@ proc libra_shell_write_db { } {
#@   foreach db $::lc_intermediate_db_files {
#@     write_lib $db -o $::legacy_lc_result_path/$::legacy_lc_log_path/$db.db
#@   }
#@ }
#@ 
#@ proc gen_common_shell_read_lib_procedure { fileName args} {
#@   puts $fileName "##@@@## gen_common_shell_read_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "set librs \[get_libs\]"
#@   puts $fileName "for {set i 0} {\$i < \[ sizeof \$librs \]} {incr i 1} {"
#@   puts $fileName "  set lib \[index_collection \$librs \$i]"
#@   puts $fileName "  redirect -var a \"query_object \$lib\" "
#@   puts $fileName "  if \[regexp {{(\")?(gtech)(\")?}} \$a\] { "
#@   puts $fileName "  } elseif \[regexp {{(\")?(standard.sldb)(\")?}} \$a] { "
#@   puts $fileName "  } else {"
#@   puts $fileName "    regexp {{(\")?(\[^\"\]*)(\")?}} \$a b c d e "
#@   puts $fileName "    write_lib \$d -o \$legacy_lc_result_path/\$legacy_lc_log_path/\$d.db"
#@   puts $fileName "  }"
#@   puts $fileName "}"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_write_lib_procedure { fileName args } {
#@   puts $fileName "foreach var \[glob -nocomplain -directory \$legacy_lc_result_path/\$legacy_lc_log_path *.db\] { read_db \$var }"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "##@@@## gen_common_shell_write_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_add_pg_pin_procedure { fileName args } {
#@   puts $fileName "##@@@## gen_common_shell_add_pg_pin"
#@   puts $fileName "eval [lindex $args 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_is_none_tech_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_non_tech_file
#@ }
#@ 
#@ proc gen_is_symbol_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_symbol_file
#@ }
#@ 
#@ proc print_no_common_shell_found {arg} {
#@   if {![file exists $arg] } {
#@     echo "Error: No common shell Library Compiler found. (LCSH-2)"
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ proc set_host_options args {
#@     global lc_cpu_allocation
#@     if {[string compare [lindex $args 0] "-max_cores"]} {
#@ 	puts "Must specify one of these options: -max_cores. (CMD-004)"
#@ 	return
#@     } elseif {[llength $args] != 2} {
#@ 	puts "value not specified for option '-max_cores' (CMD-008)"
#@ 	return
#@     }
#@     set val [lindex $args 1]
#@     if {[string is integer $val] && ($val > 0) && ($val <= 16) } {
#@ 	set lc_cpu_allocation [expr $val - 1]
#@     } else {
#@ 	puts "value $val for option '-max_cores' not in range (1-16). (CMD-019)"
#@     }
#@     return
#@ }
#@ 
#@ proc remove_host_options {} {
#@     global lc_cpu_allocation
#@     set lc_cpu_allocation 0
#@ }
#@ 
#@ proc report_host_options {} {
#@      global lc_cpu_allocation
#@      global sh_product_version
#@      puts "****************************************
#@ Report : host_options
#@ Version: $sh_product_version
#@ Date   : [date]
#@ ****************************************
#@ 
#@ Max_cores: [expr $lc_cpu_allocation + 1]
#@ "
#@ }
#@ 
#@ define_proc_attributes set_host_options \
#@   -info "Controls the maximum number of CPU cores that can be used for read_lib command." \
#@   -define_args {
#@     {-max_cores "number_of_cores" max_cores int required}
#@ }
#@ 
#@ define_proc_attributes remove_host_options -info "Removes -max_cores specification set by the set_host_options command."
#@ 
#@ define_proc_attributes report_host_options -info "Prints a report of multi-CPU processing options as defined by the set_host_options command."
#@ 
#@ # to call init_criteria() and pass lc/lc/check_library/logic_sig_digits.tcl
#@ set_check_library_options
#@ 
#@ #
#@ # .synopsys_nwtn.setup: Application initialization file 
#@ #
#@ 
#@ # Enable stack trace output on fatal.  Not available for all architectures.
#@ if { $sh_arch == "sparcOS5" || $sh_arch == "linux" } {
#@   set_unix_variable SYNOPSYS_TRACE ""
#@ }
#@ 
#@ 
#@ proc make_hex s { 
#@   binary scan $s H* hex
#@   return $hex 
#@ }
#@ 
#@ proc gen_compile_lib_procedure { fileName libName dbFileDir logFileDir } {
#@   set libBaseName [file rootname [file tail $libName]]
#@   set logFileName $::compile_libs_log_file_prefix$libBaseName$::compile_libs_log_file_suffix.log
#@   if {$::lc_compile_libs_skip_license_check != true} {
#@   puts $fileName "while { \$::compile_libs_lic_got != true } { "
#@   puts $fileName "  set result \[ get_license Library-Compiler \] "
#@   puts $fileName "  if { \$result >0 } { "
#@   puts $fileName "    set ::compile_libs_lic_got true "
#@   puts $fileName "    break "
#@   puts $fileName "  } "
#@   puts $fileName "  echo \"not got\" "
#@   puts $fileName "  after 30000" 
#@   puts $fileName "}" 
#@   }
#@   puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@   puts $fileName "  echo \"var not exported\" "
#@   export_tcl_var $fileName
#@   puts $fileName "  set ::compile_libs_var_exported true"
#@   puts $fileName "}"
#@   #puts $fileName "info hostname"
#@   #puts $fileName "date"
#@   if { $logFileDir == "" } {
#@     set logFileDir [pwd]
#@   }
#@   puts $fileName "redirect -file $logFileDir/$logFileName { set librs \[read_lib $libName -return_lib_collection\] }"
#@   puts $fileName "for {set i 0} {\$i < \[ sizeof \$librs \]} {incr i 1} {"
#@   puts $fileName "  set lib \[index_collection \$librs \$i]"
#@   puts $fileName "  redirect -var a \"query_object \$lib\" "
#@   puts $fileName "  regexp {{(\")?(\[^\"\]*)(\")?}} \$a b c d e "
#@   if { $dbFileDir == "" } {
#@     set dbFileDir [pwd]
#@   }
#@   puts $fileName "  write_lib \$d -o $dbFileDir/\$d.db"
#@   puts $fileName "}"
#@   #puts $fileName "incr ::compile_libs_count"
#@   #puts $fileName "echo \"\[info hostname\]_compile_libs_count : \$::compile_libs_count\""
#@   puts $fileName "if { \[ sizeof_collection \$librs \] >0 } {"
#@   puts $fileName "  set sucFlag \[ open $::compile_libs_temp_directory/sucFlags/\[file tail $libName\] a \]"
#@   puts $fileName "  close \$sucFlag "
#@   puts $fileName "} else {"
#@   puts $fileName "  set failFlag \[ open $::compile_libs_temp_directory/failFlags/\[file tail $libName\] a \]"
#@   puts $fileName "  close \$failFlag "
#@   puts $fileName "}"
#@   
#@ }
#@ 
#@ proc gen_create_frame_from_lef_proc { fileName } {
#@    puts $fileName "proc create_frame_from_lef { lefFiles framePath techName scaleFactor minCoverDbs postScript } {"
#@    puts $fileName "  set __cmd \[list create_physical_lib\]"
#@    puts $fileName "  set __frameTailName \[file tail \$framePath\]"
#@    puts $fileName "  set __frameTailRootName \[file rootname \$__frameTailName\]"
#@    puts $fileName "  lappend __cmd \$__frameTailRootName"
#@    puts $fileName "  if { \$techName != \"\" } {"
#@    puts $fileName "    lappend __cmd \"-technology\""
#@    puts $fileName "    lappend __cmd \$techName"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$scaleFactor != \"\" } {"
#@    puts $fileName "    lappend __cmd \"-scale_factor\""
#@    puts $fileName "    lappend __cmd \$scaleFactor"
#@    puts $fileName "  }"
#@    puts $fileName "  eval \$__cmd"
#@    puts $fileName "  read_lef \$lefFiles -direct_to_frame"
#@    puts $fileName "  if { \$minCoverDbs != \"\" } {"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$minCoverDbs"
#@    puts $fileName "    recreate_frame"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$postScript != \"\" } {"
#@    puts $fileName "    source -echo -verbose \$postScript"
#@    puts $fileName "  }"
#@    puts $fileName "  write_physical_lib -force -output \$framePath"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_generate_frame_from_mw_proc { fileName } {
#@    puts $fileName "proc generate_frame_from_mw_wrapper { mwLibPath framePath logFileDir minCoverDbs internal useIcc } {"
#@    puts $fileName "  if { \$internal } {"
#@    puts $fileName "    set internalOpt \"-internal\""
#@    puts $fileName "  } else {"
#@    puts $fileName "    set internalOpt \"\""
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$useIcc } {"
#@    puts $fileName "    set useIccOpt \"-use_icc\""
#@    puts $fileName "  } else {"
#@    puts $fileName "    set useIccOpt \"\""
#@    puts $fileName "  }"
#@    puts $fileName "  eval generate_frame_from_mw \$framePath -mw_lib \$mwLibPath -log_file_dir \$logFileDir \$internalOpt \$useIccOpt"
#@    puts $fileName "  open_physical_lib \$framePath"
#@    puts $fileName "  if { \$minCoverDbs != \"\" } {"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$minCoverDbs"
#@    puts $fileName "    recreate_frame"
#@    puts $fileName "  }"
#@    puts $fileName "  write_physical_lib -force -output \$framePath"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_recreate_frame_proc { fileName } {
#@    puts $fileName "proc recreate_frame {} {"
#@    puts $fileName "  set __lib_cells \[get_physical_lib_cells -quiet */*/design\]"
#@    puts $fileName "  foreach_in_collection __design_view \$__lib_cells {"
#@    puts $fileName "    set __modified \[get_attribute \${__design_view} is_modified\]"
#@    puts $fileName "    if { \$__modified == \"true\" } {"
#@    puts $fileName "      set __lib_cell_name \[get_attribute \$__design_view name\]"
#@    puts $fileName "      set __config_mode \[get_attribute \$__design_view config_frame_option_mode\]"
#@    puts $fileName "      if { \$__config_mode != \"\" } {"
#@    puts $fileName "        configure_frame_options -auto_run_create_frame -mode \$__config_mode \${__lib_cell_name}"
#@    puts $fileName "      } else {"
#@    puts $fileName "        create_frame \${__lib_cell_name}"
#@    puts $fileName "      }"
#@    puts $fileName "    }"
#@    puts $fileName "  }"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_remove_physical_cells_proc { fileName } {
#@    puts $fileName "proc remove_physical_cells { removeCellNames } {"
#@    puts $fileName "  foreach __cell_name \$removeCellNames {"
#@    puts $fileName "    foreach __view_name { design frame layout } {"
#@    puts $fileName "      catch {"
#@    puts $fileName "        set __cells_to_remove \[ get_physical_lib_cells -quiet */\${__cell_name}/\${__view_name} \]"
#@    puts $fileName "        if { \[sizeof_collection \${__cells_to_remove} \] > 0 } {"
#@    puts $fileName "          remove_physical_lib_cells \${__cells_to_remove}"
#@    puts $fileName "        }"
#@    puts $fileName "      }"
#@    puts $fileName "    }"
#@    puts $fileName "  }"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_cdpl_header_procedure { fileName restoreProcessScript setPolicyScript} {
#@    puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@    puts $fileName "  echo \"var not exported\" "
#@    export_flib_tcl_var $fileName
#@    puts $fileName "  set ::compile_libs_var_exported true"
#@    puts $fileName "}"
#@ 
#@    puts $fileName "if { \$::compile_libs_app_opt_exported != true } {"
#@    puts $fileName "  echo \"app options not exported\" "
#@    export_app_options $fileName
#@    puts $fileName "  set ::compile_libs_app_opt_exported true"
#@    puts $fileName "}"
#@ 
#@    if {$restoreProcessScript != ""} {
#@      puts $fileName "if { \$::compile_libs_process_label_exported != true } {"
#@      puts $fileName "  echo \"process label setting not exported\" "
#@      puts $fileName $restoreProcessScript
#@      puts $fileName "  set ::compile_libs_process_label_exported true"
#@      puts $fileName "}"
#@    }
#@ 
#@    if {$setPolicyScript != ""} {
#@      puts $fileName "if { \$::compile_libs_set_policy_exported != true } {"
#@      puts $fileName "  echo \"early data check policy setting not exported\" "
#@      puts $fileName $setPolicyScript
#@      puts $fileName "  set ::compile_libs_set_policy_exported true"
#@      puts $fileName "}"
#@    }
#@ }
#@ 
#@ proc gen_check_status_procedure { fileName statusFile useReturn } {
#@    puts $fileName "if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "  set __sucFlag \[ open $::compile_libs_temp_directory/sucFlags/$statusFile a \]"
#@    puts $fileName "  close \$__sucFlag "
#@    if { $useReturn } {
#@      puts $fileName "  return 1"
#@    } else {
#@      puts $fileName "  exit 0"
#@    }
#@    puts $fileName "} else {"
#@    puts $fileName "  set __failFlag \[ open $::compile_libs_temp_directory/failFlags/$statusFile a \]"
#@    puts $fileName "  close \$__failFlag "
#@    if { $useReturn } {
#@      puts $fileName "  return 0"
#@    } else {
#@      puts $fileName "  exit 1"
#@    }
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_compile_flib_script { useCdpl index libPath dbNames frameNdms dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath maxThreadCount verbose {removeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $frameNdms!="" } {
#@      set frameNdmsOpt "-frames $frameNdms"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    if { $removeCellNames != "" } {
#@      gen_remove_physical_cells_proc $fileName
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    if { $removeCellNames != "" } {
#@    puts $fileName "      remove_physical_cells {$removeCellNames}"
#@    }
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_from_lef_script { useCdpl index libPath dbNames lefNames framePathes techName scaleFactor postScripts dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath maxThreadCount verbose {minCoverDbs ""} {includeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $framePathes!="" } {
#@      set frameNdmsOpt "-frames $framePathes"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_create_frame_from_lef_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __saved_include_design_filters \"[get_app_option_value -name physical_lib.include_design_filters]\""
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value $includeCellNames"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __lefNames $lefNames"
#@    puts $fileName "    set __framePathes $framePathes"
#@    puts $fileName "    set __postScripts $postScripts"
#@    puts $fileName "    set __index 0"
#@    puts $fileName "    set __frameNum [llength $lefNames]"
#@    puts $fileName "    for {} {\$__index < \$__frameNum} {incr __index} {"
#@    puts $fileName "      set __lefFiles \[lindex \$__lefNames \$__index\]"
#@    puts $fileName "      set __framePath \[lindex \$__framePathes \$__index\]"
#@    puts $fileName "      set __postScript \[lindex \$__postScripts \$__index\]"
#@ 
#@    puts $fileName "      catch {"
#@    puts $fileName "        create_frame_from_lef \$__lefFiles \$__framePath {$techName} {$scaleFactor} {$minCoverDbs} \$__postScript"
#@    puts $fileName "      }"
#@    puts $fileName "      close_physical_lib"
#@    puts $fileName "    }"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value \$__saved_include_design_filters"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_from_mw_script { useCdpl index libPath dbNames mwLibPathes framePathes dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath logFileDir maxThreadCount allow10NmMw verbose {minCoverDbs ""} {includeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $framePathes!="" } {
#@      set frameNdmsOpt "-frames $framePathes"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_generate_frame_from_mw_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __saved_include_design_filters \"[get_app_option_value -name physical_lib.include_design_filters]\""
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value $includeCellNames"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __mwLibPathes $mwLibPathes"
#@    puts $fileName "    set __framePathes $framePathes"
#@    puts $fileName "    set __logFileDir $logFileDir"
#@    puts $fileName "    set __index 0"
#@    puts $fileName "    set __frameNum [llength $framePathes]"
#@    puts $fileName "    for {} {\$__index < \$__frameNum} {incr __index} {"
#@    puts $fileName "      set __mwLibPath \[lindex \$__mwLibPathes \$__index\]"
#@    puts $fileName "      set __framePath \[lindex \$__framePathes \$__index\]"
#@ 
#@    puts $fileName "      catch {"
#@    puts $fileName "        generate_frame_from_mw_wrapper \$__mwLibPath \$__framePath \$__logFileDir {$minCoverDbs} $allow10NmMw $useCdpl"
#@    puts $fileName "      }"
#@    puts $fileName "      close_physical_lib"
#@    puts $fileName "    }"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value \$__saved_include_design_filters"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_lef_to_frame_script { useCdpl index lefName framePath techName scaleFactor postScript logFilePath tclFilePath maxThreadCount verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameTailRootName [file rootname $frameTailName]
#@    set statusFile "lef_to_frame_${index}_${frameTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_create_frame_from_lef_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@    puts $fileName "    create_frame_from_lef $lefName $framePath {$techName} {$scaleFactor} {} {$postScript}"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ # this is for icc shell
#@ proc gen_compile_flib_dump_mw_fram_script { useCdpl index mwLibPath dataPath logFilePath tclFilePath allow10NmMw verbose } {
#@    set mwLibTailName [file tail $mwLibPath]
#@    set mwLibTailRootName [file rootname $mwLibTailName]
#@    set statusFile "dump_mw_fram_${index}_${mwLibTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $allow10NmMw } {
#@      set internalOpt "-internal"
#@    } else {
#@      set internalOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    export_icc2_frame -library $mwLibPath -output_directory $dataPath $internalOpt"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile $useCdpl
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ # this is for lc shell
#@ proc gen_compile_flib_generate_frame_from_mw_data_script { useCdpl index mwLibPath dataFilePath framePath techName logFilePath tclFilePath verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameDirName [file dirname $framePath]
#@    set statusFile "generate_frame_from_mw_data_${index}_${frameTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -append -file $logFilePath {"
#@    puts $fileName "  set __pwd [pwd]"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    cd $frameDirName"
#@    puts $fileName "    create_physical_lib $frameTailName -technology $techName"
#@    puts $fileName "    import_icc_fram $dataFilePath"
#@    puts $fileName "    write_physical_lib -output $framePath"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  cd \$__pwd"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_generate_frame_from_mw_fram_script { useCdpl index mwLibPath framePath logFilePath tclFilePath logFileDir allow10NmMw verbose } {
#@    set frameTailName [file tail $framePath]
#@    set statusFile "generate_frame_from_mw_fram_${index}_${frameTailName}"
#@ 
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $allow10NmMw } {
#@      set internalOpt "-internal"
#@    } else {
#@      set internalOpt ""
#@    }
#@    if { $useCdpl } {
#@      set useIccOpt "-use_icc"
#@    } else {
#@      set useIccOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    generate_frame_from_mw $framePath -mw_lib $mwLibPath -log_file_dir $logFileDir $internalOpt $useIccOpt"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_create_dummy_frame_script { framePath techName scaleFactor logFilePath tclFilePath verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameTailRootName [file rootname $frameTailName]
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    if { $scaleFactor != "" } {
#@      set scaleFactor "-scale_factor $scaleFactor"
#@    }
#@ 
#@    if { $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    create_physical_lib $frameTailRootName -technology $techName $scaleFactor"
#@    puts $fileName "    write_physical_lib -output $framePath"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    puts $fileName "if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "  return 1"
#@    puts $fileName "} else {"
#@    puts $fileName "  return 0"
#@    puts $fileName "}"
#@   
#@    close $fileName
#@ }
#@ 
#@ proc gen_compile_flib_update_frame_script { useCdpl index frameNdm logFilePath tclFilePath maxThreadCount verbose {minCoverDbs ""} } {
#@    set fileName [open $tclFilePath a]
#@ 
#@    set frameNdm [file normalize $frameNdm]
#@    set libName [file tail $frameNdm]
#@    set statusFile "update_frame_${index}_${libName}"
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@ 
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __frameNdm \"$frameNdm\""
#@    puts $fileName "    set __minCoverDbs \"$minCoverDbs\""
#@    puts $fileName "    open_physical_lib \$__frameNdm"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$__minCoverDbs"
#@    puts $fileName "    recreate_frame"
#@    puts $fileName "    write_physical_lib -force -output \$__frameNdm"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  close_physical_lib"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_source_lm_migration_scripts_procedure { index lmTclPath logFileDir maxThreadCount } {
#@    set prefix "source_lm_migration_scripts_"
#@    set prefixI "$prefix$index"
#@    set cwd "${::compile_libs_cwd}"
#@    set wrkDir "${cwd}/${prefixI}"
#@    set tclFileName "$::compile_libs_script_path/${prefixI}"
#@    set fileName [open $tclFileName a]
#@    set logFileName ${prefixI}.log
#@    puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@    puts $fileName "  echo \"var not exported\" "
#@    export_tcl_var $fileName
#@    puts $fileName "  set ::compile_libs_var_exported true"
#@    puts $fileName "}"
#@    puts $fileName "set suc -1"
#@    if { $logFileDir=="" } {
#@      set logFileDir ${cwd}
#@    }
#@    set cmd "redirect -file $logFileDir/$logFileName { set suc \[set_host_options -max_cores $maxThreadCount; report_host_options"
#@    puts $fileName "$cmd; file delete -force $wrkDir; file mkdir $wrkDir; cd $wrkDir; source -echo -verbose $lmTclPath; cd ${cwd}] }"
#@    puts $fileName "if { 1 } {"
#@    puts $fileName "  set sucFlag \[ open $::compile_libs_temp_directory/sucFlags/\[file tail $lmTclPath\] a \]"
#@    puts $fileName "  close \$sucFlag "
#@    puts $fileName "} else {"
#@    puts $fileName "  set failFlag \[ open $::compile_libs_temp_directory/failFlags/\[file tail $lmTclPath\] a \]"
#@    puts $fileName "  close \$failFlag "
#@    puts $fileName "}"
#@   
#@    close $fileName
#@ }
#@ 
#@ proc report_compile_libs { } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set failLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/failFlags * ]
#@   set failSuclibs "" 
#@   foreach lib $failLibs {
#@     lappend failSuclibs  [file tail $lib]  
#@   }
#@   foreach lib $sucLibs {
#@     lappend failSuclibs [file tail $lib]  
#@   }
#@   set allLibs ""
#@   foreach lib $::compile_lib_list {
#@     lappend allLibs [file tail $lib]  
#@   }
#@   set allLibs [ lsort -unique $allLibs ]
#@   set failSuclibs [ lsort -unique $failSuclibs ]
#@   set index2 0
#@   set fatalLibs ""
#@   foreach libBaseName $allLibs {
#@     #echo $libBaseName, [lindex $failSuclibs $index2]
#@     if { $libBaseName != [lindex $failSuclibs $index2] } {
#@       lappend fatalLibs $libBaseName
#@       continue
#@     } else {
#@       incr index2
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "[llength $sucLibs] libs are compiled successfully, [llength $failLibs] failed, [llength $fatalLibs] fatal."
#@   set failSuclibs "" 
#@   set nFail [llength $failLibs]
#@   if { $nFail > 0} {
#@     echo "The following are the failed list. Please check the log file for details."
#@     foreach lib $failLibs {
#@       echo [file tail $lib]
#@     }
#@   }
#@   set nFatal [llength $fatalLibs]
#@   if { $nFatal > 0} {
#@     echo "The following libs meet unexpected error which cause LC to be fatal. Please contact support from Synopsys."
#@     foreach lib $fatalLibs {
#@       echo $lib
#@     }
#@   }
#@   return [expr $nFail + $nFatal]
#@ }
#@ 
#@ proc report_run_result { work logFileDir } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set failLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/failFlags * ]
#@   set failSuclibs "" 
#@   foreach lib $failLibs {
#@     lappend failSuclibs  [file tail $lib]  
#@   }
#@   foreach lib $sucLibs {
#@     lappend failSuclibs [file tail $lib]  
#@   }
#@   set allLibs ""
#@   foreach lib $::compile_lib_list {
#@     lappend allLibs [file tail $lib]  
#@   }
#@   set allLibs [ lsort -unique $allLibs ]
#@   set failSuclibs [ lsort -unique $failSuclibs ]
#@   set index2 0
#@   set fatalLibs ""
#@   foreach libBaseName $allLibs {
#@     #echo $libBaseName, [lindex $failSuclibs $index2]
#@     if { $libBaseName != [lindex $failSuclibs $index2] } {
#@       lappend fatalLibs $libBaseName
#@       continue
#@     } else {
#@       incr index2
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "[llength $sucLibs] $work successfully, [llength $failLibs] failed, [llength $fatalLibs] fatal."
#@   set failSuclibs "" 
#@   set nFail [llength $failLibs]
#@   if { $nFail > 0} {
#@     echo "Error: there are failed libs. Please check following log files for detail."
#@     foreach lib $failLibs {
#@       if { $logFileDir != "" } {
#@         echo "${logFileDir}/[file tail $lib].log"
#@       } else {
#@         echo "[file tail $lib].log"
#@       }
#@     }
#@   }
#@   set nFatal [llength $fatalLibs]
#@   if { $nFatal > 0} {
#@     echo "The following libs meet unexpected error which cause LC to be fatal. Please contact support from Synopsys."
#@     foreach lib $fatalLibs {
#@       echo $lib
#@     }
#@   }
#@   return [expr $nFail + $nFatal]
#@ }
#@ 
#@ proc report_source_lm_migration_scripts { debug } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set sucLibsCnt [llength $sucLibs]
#@   # move generated directories (*.ndm, *.nlib or more?) to ./
#@ #  foreach dir [glob -nocomplain -type d $::compile_libs_cwd/source_lm_migration_scripts_*/*] {
#@ #    set dest "$::compile_libs_cwd/[file tail $dir]"
#@ #    file delete -force $dest
#@ #    file rename -force $dir $dest 
#@ #  }
#@   # and then delete source_lm_migration_scripts_*
#@ #  foreach dir [glob -nocomplain -type d $::compile_libs_cwd/source_lm_migration_scripts_*] {
#@ #    file delete -force $dir
#@ #  }
#@   # delete tmp hidden dir
#@   if { $debug == false } {
#@     set scripts [glob -nocomplain -directory  $::compile_libs_script_path * ]
#@     if { [llength $scripts] == $sucLibsCnt } {
#@       ### add a short sleep before the delete waiting for file handle close
#@       set ::img_create_sleep 0
#@       after 5000 [list set ::img_create_sleep 1]
#@       vwait ::img_create_sleep
#@       file delete -force $::compile_libs_temp_directory
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "$sucLibsCnt scripts are run. Please check the log file for details."
#@ }
#@ 
#@ 
#@ # create the unique folder under tmp
#@ proc set_script_path_var { processDirName } {
#@   set fileName .[pid]
#@   set var [append fileName "_" [clock microseconds]] 
#@   file delete -force [pwd]/$var
#@   file mkdir [pwd]/$var/
#@   file mkdir [pwd]/$var/preCompile
#@   file mkdir [pwd]/$var/$processDirName
#@   file mkdir [pwd]/$var/sucFlags
#@   file mkdir [pwd]/$var/failFlags
#@   file mkdir [pwd]/$var/cdpl
#@   setenv CDPL_LOGDIR "[pwd]/$var/cdpl"
#@   set ::compile_libs_temp_directory "[pwd]/$var"
#@   set ::compile_libs_pre_script_path "[pwd]/$var/preCompile"
#@   set ::compile_libs_script_path  "[pwd]/$var/$processDirName"
#@   set ::compile_libs_cdpl_log_directory "[pwd]/$var/cdpl"
#@   set ::compile_libs_cwd "[pwd]"
#@   set ::compile_lib_list ""
#@ }
#@ 
#@ proc gen_get_lic_scripts { } {
#@   set tclFileName "$::compile_libs_pre_script_path/get_lic"
#@   set chan [open $tclFileName a]
#@   export_tcl_var $chan
#@   #puts $chan "info hostname"
#@   #puts $chan "date"
#@   #puts $chan "get_license Library-Compiler"
#@   puts $chan "set ::compile_libs_var_exported true"
#@   puts $chan "after 5000"
#@   close $chan
#@ }
#@ 
#@ proc gen_compile_lib_scripts { search_path libNamePattern dbFileDir logFileDir } {
#@   foreach path $search_path {
#@     set path [ file normalize $path]
#@      foreach pattern $libNamePattern {
#@        set ::compile_lib_list [concat $::compile_lib_list [ glob -nocomplain -directory $path $pattern] ]
#@      }
#@   }
#@   set ::compile_lib_list [lsort -unique $::compile_lib_list]
#@   set i 1
#@   foreach libFileName $::compile_lib_list {
#@     set tclFileName "$::compile_libs_script_path/read_lib_$i"
#@     #echo $tclFileName
#@     set chan [open $tclFileName a]
#@     #echo $libFileName
#@     gen_compile_lib_procedure $chan $libFileName $dbFileDir $logFileDir
#@     close $chan
#@     incr i
#@   }
#@ }
#@ 
#@ proc __rename_commands { cmd_black_list } {
#@   set all_cmds [get_defined_commands]
#@   foreach cmd $all_cmds {
#@     if  { [lsearch $cmd_black_list $cmd] != -1 } {
#@       rename -hidden -force $cmd ____$cmd
#@     }
#@   }
#@ }
#@ 
#@ # 
#@ # STAR P80014807-4612
#@ # FL - reserve relative paths to FL directory - instead of golden db/frames
#@ #
#@ # /site1/data/golden/DB
#@ # /site1/data/golden/frame
#@ # 
#@ # assumption: run under the flib dir 
#@ #   /site1/flib
#@ # should have /site1/flib/registry.dat
#@ # 
#@ # Before:
#@ # 
#@ # /site1/flib/1.db -> /site1/data/golden/DB/1.db
#@ # /site1/flib/2.db -> /site1/data/golden/DB/2.db
#@ # /site1/flib/1.ndm -> /site1/data/golden/frame/1.ndm
#@ # 
#@ # After:  
#@ # 
#@ # /site1/flib/1.db -> ../data/golden/DB/1.db
#@ # /site1/flib/2.db -> ../data/golden/DB/2.db
#@ # /site1/flib/1.ndm -> ../data/golden/frame/1.ndm
#@ #
#@ proc countChar {str mapvar} {
#@   return [expr [string length $str]-[string length [string map $mapvar $str]]]
#@ }
#@ proc findHead {s1 s2} {
#@   set head ""
#@   set ts1 [string trim $s1 /]
#@   set ts2 [string trim $s2 /]
#@   foreach w1 [split $ts1 /] w2 [split $ts2 /] {
#@     append head "/" 
#@     if {$w1 eq $w2} {append head $w1} else break
#@   }
#@   return $head 
#@ }
#@ proc __make_data_path_relative { flibPath } {
#@   set curPath [pwd]
#@   set flibPath [file normalize $flibPath]
#@ 
#@   cd $flibPath
#@   set numSlashCur [countChar $flibPath {/ ""} ]
#@ 
#@   # for each symlink (should linked to full path)
#@   foreach linkName [glob -nocomplain -type l *] { 
#@     # get linked full path $absPath
#@     set absPath [file readlink $linkName]
#@     if {[string index $absPath 0] != "/"} {
#@       # already relative
#@       continue; 
#@     }
#@ 
#@     # not guaranteed if "realpath --relative-to" is available 
#@     # set relPath [sh realpath --relative-to=[pwd] $absPath]
#@     # compare $flibPath with $absPath, remove common head, set $relPath = ".../tail"
#@     set head [findHead $flibPath $absPath]
#@     set tail [string range $absPath [string length $head] end]
#@     set numSlashHead [countChar $head {/ ""}]
#@     set numLevelUp [expr $numSlashCur - $numSlashHead + 1]
#@     set pathPrefix [string repeat "../" $numLevelUp]
#@     set relPath $pathPrefix$tail
#@ 
#@     set __catched [ catch {
#@       # re-link the $linkName to $relPath
#@       echo "Linking $linkName to $relPath"
#@       file delete $linkName
#@       file link $linkName $relPath
#@     } ]
#@     if { $__catched } {
#@       echo "Failed."
#@       cd $curPath
#@       return -code error
#@     } else {
#@       echo "Succeeded."
#@     }
#@   }
#@   echo "Information: Data path made relative to $flibPath"
#@   cd $curPath
#@ }
#@ 
#@ source ${synopsys_root}/auxx/LC2/check_lib_common_lc.tbc
#@ # -- Starting source /tools/software/synopsys/lc/latest/auxx/LC2/check_lib_common_lc.tbc

#@ ##############################################################################
#@ # Author : Yun Zhang
#@ # History: 2020/6/22 created
#@ # Description: This is the source tcl file of check_lib_common_lc.tbc.
#@ #              The procs are all for run common library compiler under the hood.
#@ ##############################################################################
#@ # TclPro::Compiler::Include
#@ 
#@ if {[catch {package require tbcload 1.6} err] == 1} {
#@     return -code error "[info script]: The TclPro ByteCode Loader is not available or does not support the correct version -- $err"
#@ }
#@ tbcload::bceval {
#@ TclPro ByteCode 2 0 1.7 8.5
#@ 20 0 200 30 0 0 156 0 4 20 20 -1 -1
#@ 200
#@ A2F<!(H&s!/HW<!(3E<!2`8s!F_#pv2/YQ#/HW<!-Qr<!2`8s!I%ul#/2:3w/HW<!0c8=!2`
#@ 8s!K7VNw1Dpiw/HW<!2oJ=!2`8s!MI70%@.mf%/HW<!4&|=!2`8s!Pd3-&6qMH&/HW<!78#>
#@ !2`8s!R!jc&JjJE'/HW<!9D5>!2`8s!U<f`';I+'(/HW<!<VP>!2`8s!WNGB(TQ(w)/HW<!>
#@ bb>!2`8s!ZiC?)Zuw!*/HW<!At(?!/E<!!
#@ 20
#@ @1IOwI1IOwI1IOwI1IOwI1IOw
#@ 20
#@ I%%n#I%%n#I%%n#I%%n#Hq^R#
#@ 30
#@ x
#@ 4
#@ ,CHr@
#@ x
#@ 27
#@ lj|Z?w3F/Du'VgC&>m#H8&Z)F5mNaEt-E-
#@ x
#@ 1
#@ A!
#@ p
#@ 5 0 29 3 0 0 20 0 9 5 5 -1 -1
#@ 29
#@ w0E<!w0E<!w0E<!w0E<!6P1qv3&5pv-E<!!z
#@ 5
#@ )|y9v%!
#@ 5
#@ 'wwi%*!
#@ 3
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 7
#@ %H9KDUvg+
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 22
#@ epCkBo0m*EpvnX?3DccE,&MEFO(%
#@ x
#@ 7
#@ /^,8AY@c,
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 2
#@ a,v
#@ p
#@ 26 0 375 16 2 0 144 1 7 26 38 -1 -1
#@ 375
#@ 32fv!8^w!!.H!!!w3E<!JAe`B#1NW<#3WW!(H&s!>SN?!,Ki<!6h)g%0#>6#@Yw4w1/GpvQk
#@ s<!QSa<!2l+dB<jTZ)v*<<!(H&s!8Qr<!=>YQ#5l+UvVL_w!AqXaB:Xs#)v*<<!:>T=!;eQj
#@ w4u&v!>SGY!8^w!!c?)!!'NA9v3DUNw5Qr<!=>YQ#5l+Uv<b7U-CV%Qb5v!!!kv!!!laykBy
#@ 6fr3v*<<!3Jpiw4S60%6fSs!9YQK%AIuaB+&13wv*<<!Xg_bB4v&*'v*<<!4S60%6fSs!KDe
#@ `BKGBK.v*<<!,`yTv6fSs!TIuaB+&13wv*<<!P1caB+&13wv*<<!wO2,!DI_w!gA*07v*<<!
#@ 4S60%6fSs!R0n<vujZRI#3WW!yLDI/F*W8sREPt!5v!!!F!!!!(E`<!8,,pvFaKL&5v!!!.!
#@ !!!?:WH&ISa<!WSa<!GN2,!-i8v!,,:3wv!!!
#@ 26
#@ =+@n#-.^B)XX%n#I=.n#L@!kwc|9p#Bc!
#@ 38
#@ 4N3<!)^k|vlg)urcv7il5w*!!aBpQ%NORS#g%74wwaKU#:E!
#@ 16
#@ x
#@ 17
#@ w3F/D'gi'FrZ!iCnc%UA/v
#@ x
#@ 7
#@ &OQ<@xe|+
#@ x
#@ 5
#@ ijkIDBv
#@ x
#@ 17
#@ k%PJ:qw!d;&MC0:qkXJ:u!
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ 1lo(F^(%
#@ x
#@ 1
#@ P!
#@ x
#@ 9
#@ q3HQBb!cr@4v
#@ x
#@ 9
#@ V:wLD5Q<JDP!
#@ x
#@ 1
#@ R!
#@ i
#@ 0
#@ x
#@ 15
#@ -#l#H8&Z)F5mNaEt-E-
#@ x
#@ 8
#@ %xRQB:p2TA
#@ x
#@ 8
#@ i%97A&jmMC
#@ x
#@ 8
#@ qLK;@0dhTA
#@ x
#@ 0
#@ 
#@ 2
#@ L 0 171 102 317 274 -1
#@ C 0 288 14 -1 -1 300
#@ 0
#@ 0 3
#@ 8
#@ rmBq@NjkSA
#@ 0 0 0
#@ 9
#@ rmBq@q,BCF4v
#@ 1 0 0
#@ 4
#@ %xRQB
#@ 2 0 0
#@ x
#@ 18
#@ #k|Z?w3F/Du'VgCf!Q<@y(%
#@ p
#@ 25 0 255 17 0 0 104 0 3 25 25 -1 -1
#@ 255
#@ w0E<!KN2,!EOhw!#0E<!+BE<!41fg&5v!!!/!!!!w-<<!^Kn<v>Me`BJ>'0.#3WW!0#>6#3#
#@ Ts!TG;I/m&3,!/uJv!#0E<!Ga++'M`yTv8^w!!JGv!!*cvpv5JUNw'qrD!:1fg&5v!!!/!!!
#@ !/oJ=!fKn<v>Me`BLP|f.#3WW!0#>6#82Ts!TG;I/o,3,!1,|v!#0E<!CYCqvxKn<v>Me`BJ
#@ >'0.#3WW!0#>6#:8Ts!TG;I/m&3,!/uJv!#0E<!H=J*'M`yTv8^w!!JGv!!*cvpv:v3-&'qr
#@ D!:1fg&5v!!!/!!!!48#>!_Kn<v'0!!
#@ 25
#@ 9egm#KeHK%KeHK%KeHK%?ur!!K;s!!/!
#@ 25
#@ ^'nK%j@<L%j@<L%nRr-&`sMR#ipMR#/!
#@ 17
#@ x
#@ 17
#@ hgtdD/BsJDZnmX?1lo(F@v
#@ x
#@ 4
#@ 8w`TA
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 7
#@ &OQ<@xe|+
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 3
#@ kL2-
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ i
#@ 0
#@ x
#@ 4
#@ MyB,E
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 27
#@ w3F/Du'VgCjNIQBiOjY?w3F/D.jAn/e.Q,
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 20
#@ 3aMTAr-!eD/BsJDZnmX?4|k)F
#@ p
#@ 24 0 195 12 0 0 96 0 3 24 24 -1 -1
#@ 195
#@ w0E<!-fSs!O,uc/ViA9v,|8X!M`yTv8^w!!B/v!!w-*!!*`vpv'qrD!-A77w.r=6#Omm<v>M
#@ e`BBKMT+#3WW!w0E<!3#Ts!O,uc/ViA9v2o8X!M`yTv8^w!!B/v!!w-*!!-&tl#'qrD!-A77
#@ w0/tl#Omm<v>Me`BBKMT+#3WW!w0E<!5)Ts!O,uc/ViA9v4u8X!M`yTv8^w!!B/v!!w-*!!/
#@ 8UNw'qrD!-A77w2AUNwOmm<v'0!!
#@ 24
#@ /JHK%CeHK%CeHK%CeHK%CeHK%CeHK%
#@ 24
#@ QMbpvZMbpvZMbpvZMbpvZMbpvYMbpv
#@ 12
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 3
#@ kL2-
#@ x
#@ 17
#@ hgtdD/BsJDZnmX?1lo(F@v
#@ i
#@ 0
#@ x
#@ 5
#@ 3aMTA@v
#@ x
#@ 0
#@ 
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 21
#@ w3F/Du'VgCf-DTA@)QDFq,BCF4v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 8
#@ k^YSAqP(yG
#@ x
#@ 1
#@ ?v
#@ p
#@ 2 0 26 4 0 0 8 0 5 2 2 -1 -1
#@ 26
#@ w0E<!.9`W!0&5Uv8^w!!-E!!!-iA=!z
#@ 2
#@ .H!
#@ 2
#@ :E!
#@ 4
#@ x
#@ 6
#@ gd|;@b:%
#@ x
#@ 4
#@ rwIID
#@ x
#@ 2
#@ >Kv
#@ x
#@ 3
#@ g'i-
#@ 0
#@ 0
#@ 1 2
#@ 1
#@ ?v
#@ 0 0 256
#@ 3
#@ g'i-
#@ 1 0 0
#@ x
#@ 24
#@ #k|Z?w3F/Du'VgCd?<eDtc/bEu,aaE
#@ p
#@ 9 0 92 15 0 0 36 0 6 9 9 -1 -1
#@ 92
#@ )Nr<!I>e`BQ(;E0#3WW!+I*%;v9o7-S^w!!;o!!!w3E<!*TA9v.lvpv1l8X!`(kq+1oes!6G
#@ :3w:_piw<&|=!6)Ks!/HW<!:,f=!Gk60%4DkUv-E<!!
#@ 9
#@ 1GUm#I:*L%4!
#@ 9
#@ a#L>vbpy*'1!
#@ 15
#@ x
#@ 3
#@ _e|+
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ i
#@ 0
#@ x
#@ 6
#@ sT2TAIPw
#@ x
#@ 8
#@ m'cSANjkSA
#@ x
#@ 1
#@ +v
#@ x
#@ 5
#@ n0Hr@7v
#@ x
#@ 12
#@ #graEv_Bq@,0B(F
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ gpbSAPSw
#@ x
#@ 6
#@ AP5cE?Sw
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 5
#@ r!2kB>v
#@ 0
#@ 0
#@ 0 1
#@ 8
#@ m'cSANjkSA
#@ 0 0 0
#@ x
#@ 14
#@ 4rBfD1-0CFq&fwGJ%%
#@ x
#@ 10
#@ (KxhCN1-.DQ-v
#@ p
#@ 17 0 213 23 2 1 84 2 10 17 21 -1 -1
#@ 213
#@ w0E<!(H&s!*N&s!+Q&s!,T&s!CY,>!8^w!!2V'!!*i=6#4;tl#=MGY!g@#!!ee6(!H,FN-gE
#@ EfR8SUNw<P>:v8P60%.EW<!--<<!BJ:3w0T`<!Q.taBLP|f.v*<<!f!!!!6^w!!/K!!!12>:
#@ vI,s<!Hv(g7.CI.!4qVH&7P60%DPe`Bbl^l5#3WW!@A#>!T,PU,=;'v!Bb>:vJjJE'5v!!!-
#@ !!!!@=N-&?@e`'4oSs!eFNH&>thc&FO+'(2iSs!G;O8sBA6-&z
#@ 17
#@ C^No#L2#Y!_cpw)>2|X!7!
#@ 21
#@ Pf3<!:'Le#-kv:wIT%m5`NOkw/!
#@ 23
#@ x
#@ 4
#@ q#TCF
#@ x
#@ 6
#@ hIa:@PSw
#@ x
#@ 11
#@ m9.bEi`JT8eIl,
#@ x
#@ 1
#@ R!
#@ x
#@ 22
#@ q3HQBl#sJD8o(`FnlrJDu_PcEX%%
#@ x
#@ 21
#@ q3HQBkoW/DmgY8AnT_5BgKxhC1v
#@ x
#@ 18
#@ hgtdD!CIIDkcreDb^CkBHSw
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 4
#@ 4|k)F
#@ x
#@ 3
#@ j#L%
#@ x
#@ 2
#@ FVw
#@ x
#@ 5
#@ sB-<@Ev
#@ x
#@ 6
#@ 1lo(F^(%
#@ x
#@ 21
#@ 6dV<+:mui@26nlBPPW(46dV<+A!
#@ x
#@ 6
#@ !xMTAFVw
#@ i
#@ 0
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 12
#@ h-ur@E5>F+91VE+
#@ x
#@ 25
#@ ruwlB/wJ9>gd|;@>AufA'%U;@(y(S.A!
#@ x
#@ 8
#@ k^YSAqP(yG
#@ x
#@ 4
#@ wg;3I
#@ x
#@ 5
#@ P!i<+Iv
#@ 2
#@ L 0 60 144 210 50 -1
#@ C 1 105 20 -1 -1 123
#@ 1
#@ F
#@ 1 2 3
#@ 1
#@ 4
#@ 1 7
#@ 8
#@ m'cSANjkSA
#@ 0 0 256
#@ 12
#@ 'ZPDFd%+:@EAl)F
#@ 1 0 0
#@ 0
#@ 
#@ 2 0 512
#@ 0
#@ 
#@ 3 0 512
#@ 3
#@ kL2-
#@ 4 0 0
#@ 6
#@ 7,V`FW+%
#@ 5 0 0
#@ 4
#@ .0B,E
#@ 6 0 0
#@ x
#@ 21
#@ ^_`p@hp^LCcXKV@`jbSAp#K^F<v
#@ p
#@ 3 0 36 10 0 0 12 0 6 3 3 -1 -1
#@ 36
#@ /rS=!6U(+((H&s!,`yTv5Qr<!<)Ks!Qsm<v.TW<!19*!!
#@ 3
#@ @nG#
#@ 3
#@ VoE!
#@ 10
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ gpbSAPSw
#@ x
#@ 6
#@ AP5cE?Sw
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 0
#@ 
#@ x
#@ 20
#@ 3aMTAr-!eD/BsJDZnmX?4|k)F
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 23
#@ ,v(Z?w3F/Du'VgCoo3mBm+BRAyOl,
#@ x
#@ 8
#@ o4jY?m'cSA
#@ p
#@ 30 0 407 32 2 0 144 1 8 30 34 -1 -1
#@ 407
#@ w0E<!1#T=!/r=pv2G^3w-u4Uv6/Ypv9u&s!5v!!!Q!!!!7kZjwgfvdB>'6<*v*<<!,#tl#9i
#@ A=!Ebpiw8S60%=MGY!VyQK%8^w!!.H!!!2ylf%LGe`B.A-0%v*<<!G1);v8^w!!x')!!EL_w
#@ !T>puB<jTZ)v*<<!!oxR5e:NH&<;YUvPpm<vGhe`B^HGT4v*<<!H^/*'L!f`'GR+'(>bq9-X
#@ ^w!!5|!!!;RFB(Gk#t!COAI&;N2,!+|&v!d&.36VyQK%8^w!!IDv!!5vic&JjJE'J+ZUvHtP
#@ pvTIuaB+&13wv*<<!4Ta<!FN2,!aMg'!,,:3wg6#+15v!!!O!!!!pDhQ5vE3,!.oAv!#0E<!
#@ T2Bs!5v!!!+!!!!9S2U#BhYUvOmm<v4fW<!INE<!HNW<!2E9!sSWXA!FN2,!O6n%!hG307v*
#@ <<!KkB=!9_lf%,eN48;I%!!:n^qvbs7e/mQur*VyQK%8^w!!:l!!!+rXQ#Hv87wLt|X!Omm<
#@ v0K!!
#@ 30
#@ =Xv+'`Q,N%Yp`1%PLdjwY*Th%Wa<kwMhPUvQN!
#@ 34
#@ 6@&a0l*sL%!w!!!i.Wp4WF.4wMuIR5mhtpv#-|rv@3!
#@ 32
#@ x
#@ 4
#@ *dmID
#@ x
#@ 1
#@ Hv
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 20
#@ JaGQB*kbD+nEi'FrZ!iCV%BE+
#@ x
#@ 27
#@ lj|Z?w3F/Du'VgC&>m#H8&Z)F5mNaEt-E-
#@ x
#@ 4
#@ J2*D+
#@ x
#@ 12
#@ vAE-0;oU6036viC
#@ x
#@ 1
#@ >v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 14
#@ ;oW/D!e'Z?64BbCMYw
#@ x
#@ 1
#@ Cv
#@ x
#@ 0
#@ 
#@ i
#@ 0
#@ x
#@ 4
#@ 8w`TA
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 6
#@ :<ylBLYw
#@ x
#@ 5
#@ wRH<@8v
#@ x
#@ 7
#@ 9WmIDeI-,
#@ x
#@ 1
#@ X!
#@ x
#@ 7
#@ =P6X5R^`w
#@ x
#@ 1
#@ B!
#@ x
#@ 1
#@ A!
#@ x
#@ 2
#@ 2fv
#@ x
#@ 34
#@ Yl<eD,wBCFMk8c3Q@=nA&!=JD'WrSA;cN<@ktWU@HSw
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 4
#@ +u(*F
#@ x
#@ 4
#@ u3uSA
#@ x
#@ 5
#@ )lP)F1v
#@ x
#@ 0
#@ 
#@ 2
#@ L 0 119 195 331 315 -1
#@ C 0 348 12 -1 -1 358
#@ 0
#@ 1 7
#@ 8
#@ o4jY?m'cSA
#@ 0 0 256
#@ 4
#@ g3IID
#@ 1 0 0
#@ 3
#@ d4w,
#@ 2 0 0
#@ 4
#@ lWNeD
#@ 3 0 0
#@ 9
#@ ,uk)Fdd;JD1v
#@ 4 0 0
#@ 4
#@ u3uSA
#@ 5 0 0
#@ 5
#@ bT/bE>v
#@ 6 0 0
#@ x
#@ 23
#@ w3F/Du'VgCZCbOB_.aY?!aiaEnTr-
#@ x
#@ 11
#@ 0Q%hCgKxhC,tEw
#@ p
#@ 10 0 95 14 0 0 40 0 5 10 10 -1 -1
#@ 95
#@ /rS=!1Gwjw'E&s!H=rH&9N2,!4>##!#0E<!1NE<!@4`H&-fvpv5|8X!6Sp3w25bpv/o=6#7)
#@ tl#2Q/X!.EW<!5TN<!7`8s!9;|X!-BW<!>&#pv4P60%(w!!
#@ 10
#@ GFIOwG17n#/6!
#@ 10
#@ Vv)7#Gh17#,-!
#@ 14
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 4
#@ *dmID
#@ x
#@ 1
#@ -v
#@ x
#@ 14
#@ 4rBfD1-0CFq&fwGJ%%
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 41
#@ =P6X5r*r<+fF'Z?w3F/Du'VgCZCbOB_.aY?c_dX?,CHr@(okcE1v
#@ x
#@ 7
#@ A;lcE_iGw
#@ x
#@ 7
#@ =P6X5R^`w
#@ x
#@ 5
#@ )lP)F1v
#@ x
#@ 23
#@ ,v(Z?w3F/Du'VgCoo3mBm+BRAyOl,
#@ x
#@ 21
#@ ^_`p@hp^LCcXKV@`jbSAp#K^F<v
#@ 0
#@ 0
#@ 1 3
#@ 9
#@ o4jY?m'cSAQ!
#@ 0 0 256
#@ 8
#@ o4jY?m'cSA
#@ 1 0 0
#@ 4
#@ g3IID
#@ 2 0 0
#@ x
#@ 15
#@ rpwhC;Z2b3<?<+EfqT+
#@ 0
#@ 0
#@ }
#@ # -- End source /tools/software/synopsys/lc/latest/auxx/LC2/check_lib_common_lc.tbc

#@ # -- End source /tools/software/synopsys/lc/latest/admin/setup//.synopsys_lc.setup

source -echo -verbose /tmp/19700_1659133836993059/nglc_shell_command.tcl
#@ # -- Starting source /tmp/19700_1659133836993059/nglc_shell_command.tcl

#@ catch { set ::upf_ls_strategy_in_inst_name [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_suppress_message_in_etm [list [binary format H* 74727565]] }
#@ catch { set ::in_gui_session [list [binary format H* 66616c7365]] }
#@ catch { set ::rtl_load_resistance_factor [list [binary format H* 302e30]] }
#@ catch { set ::acs_user_top_compile_strategy_script [list [binary format H* 64656661756c745f746f70]] }
#@ catch { set ::find_ignore_case [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_vhdl_syntax_extensions [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_infer_mux [list [binary format H* 64656661756c74]] }
#@ catch { set ::vhdlout_write_top_configuration [list [binary format H* 46414c5345]] }
#@ catch { set ::x11_set_cursor_foreground [list [binary format H* 6d6167656e7461]] }
#@ catch { set ::hdlin_sv_blackbox_modules "" }
#@ catch { set ::acs_global_user_compile_strategy_script [list [binary format H* 64656661756c74]] }
#@ catch { set ::timing_disable_recovery_removal_checks [list [binary format H* 74727565]] }
#@ catch { set ::enable_auto_attr_spread [list [binary format H* 74727565]] }
#@ catch { set ::timing_input_port_default_clock [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_allow_is_isolated_output_check [list [binary format H* 74727565]] }
#@ catch { set ::cmds [list [binary format H* 7b2043656c6c204c65616643656c6c73206765745f666c61745f63656c6c7320226765745f666c61745f63656c6c73222066696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b2043656c6c2043656c6c73206765745f63656c6c7320226765745f63656c6c73202d68696572617263686963616c222068696572617263686963616c2c66696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b204e657420204c6561664e657473206765745f666c61745f6e65747320226765745f666c61745f6e657473222066696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c746f705f6e65745f6f665f68696572617263686963616c5f67726f75702c7365676d656e74732c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b204e657420204e65747320206765745f6e6574732020226765745f6e657473202d68696572617263686963616c22202068696572617263686963616c2c66696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c746f705f6e65745f6f665f68696572617263686963616c5f67726f75702c7365676d656e74732c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b2050696e20204c65616650696e73206765745f666c61745f70696e7320226765745f666c61745f70696e73222066696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6c6561662c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b2050696e202050696e7320206765745f70696e732020226765745f70696e73202d68696572617263686963616c22202068696572617263686963616c2c66696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6c6561662c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b20506f727420506f727473206765745f706f72747320226765745f706f727473202d68696572617263686963616c222068696572617263686963616c2c66696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6f665f6f626a656374732c7061747465726e732c6c6f676963616c2c706879736963616c207d207b2043656c6c204c696243656c6c732020226765745f6c69625f63656c6c73202a2f2a2220226765745f6c69625f63656c6c73202a2f2a2220202020202066696c7465722c71756965742c7265676578702c6e6f636173652c65786163742c6f665f6f626a656374732c7061747465726e737d]] }
#@ catch { set ::dont_touch_nets_with_size_only_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_derive_ao_supply_on_exception_conns [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_top_design_vector [list [binary format H* 46414c5345]] }
#@ catch { set ::upf_check_bias_supply_connections [list [binary format H* 74727565]] }
#@ catch { set ::timing_ignore_paths_within_block_abstraction [list [binary format H* 66616c7365]] }
#@ catch { set ::test_check_port_changes_in_capture [list [binary format H* 74727565]] }
#@ catch { set ::acs_num_parallel_jobs [list [binary format H* 31]] }
#@ catch { set ::veriloglib_cell_name_map "" }
#@ catch { set ::hdlin_keep_signal_name [list [binary format H* 616c6c5f64726976696e67]] }
#@ catch { set ::mv_allow_ls_per_macro_fanout [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_logic0_net [list [binary format H* 565353]] }
#@ catch { set ::gen_max_ports_on_symbol_side [list [binary format H* 30]] }
#@ catch { set ::timing_pocvm_corner_sigma [list [binary format H* 33]] }
#@ catch { set ::check_design_allow_inconsistent_output_port [list [binary format H* 74727565]] }
#@ catch { set ::mw_hdl_top_module_list "" }
#@ catch { set ::si_max_parallel_computations [list [binary format H* 30]] }
#@ catch { set ::power_rclock_inputs_use_clocks_fanout [list [binary format H* 74727565]] }
#@ catch { set ::compatibility_version [list [binary format H* 542d323032322e30332d535031]] }
#@ catch { set ::sh_source_logging [list [binary format H* 74727565]] }
#@ catch { set ::acs_exclude_list [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c6174657374]] }
#@ catch { set ::upf_preserve_logic_in_boolean_expr [list [binary format H* 66616c7365]] }
#@ catch { set ::read_db_lib_warnings [list [binary format H* 46414c5345]] }
#@ catch { set ::sh_arch [list [binary format H* 6c696e75783634]] }
#@ catch { set ::sdc_runtime_unused_clocks_threshold [list [binary format H* 35]] }
#@ catch { set ::compile_enable_enhanced_leakage_optimization [list [binary format H* 66616c7365]] }
#@ catch { set ::sdfout_min_rise_cell_delay [list [binary format H* 302e]] }
#@ catch { set ::view_execute_script_suffix [list [binary format H* 2e736372697074202e736372202e646373202e646376202e6463202e636f6e202e74636c]] }
#@ catch { set ::vhdllib_tb_x_eq_dontcare [list [binary format H* 46414c5345]] }
#@ catch { set ::power_cg_high_effort_enable_fanin_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_state_reachability_high_effort_merge [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_gclock_source_network_num_master_registers [list [binary format H* 3130303030303030]] }
#@ catch { set ::test_bsd_default_bidir_delay [list [binary format H* 302e30]] }
#@ catch { set ::test_core_wrap_sync_ctl_segment_length [list [binary format H* 30]] }
#@ catch { set ::tested_technology "" }
#@ catch { set ::compile_seqmap_propagate_constants_size_only [list [binary format H* 66616c7365]] }
#@ catch { set ::synlib_wait_for_design_license "" }
#@ catch { set ::x11_set_cursor_background "" }
#@ catch { set ::mw_hvo_diode_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::write_sdc_output_net_resistance [list [binary format H* 74727565]] }
#@ catch { set ::write_sdc_output_lumped_net_capacitance [list [binary format H* 74727565]] }
#@ catch { set ::de_log_redirect_enable [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_clock_to_data_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::set_isolate_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_verification_priority [list [binary format H* 46414c5345]] }
#@ catch { set ::enable_vhdl_netlist_reader [list [binary format H* 46414c5345]] }
#@ catch { set ::mw_hvo_unconnected_cells [list [binary format H* 74727565]] }
#@ catch { set ::compile_log_print_pathgroups_in_delayopt [list [binary format H* 66616c7365]] }
#@ catch { set ::report_timing_use_accurate_delay_symbol [list [binary format H* 74727565]] }
#@ catch { set ::cache_read_info [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_output_wire_declaration [list [binary format H* 66616c7365]] }
#@ catch { set ::high_fanout_net_threshold [list [binary format H* 31303030]] }
#@ catch { set ::hdlin_shorten_long_module_name [list [binary format H* 66616c7365]] }
#@ catch { set ::_mv_sort_power_pin_order [list [binary format H* 74727565]] }
#@ catch { set ::FILE [list [binary format H* 66696c653135]] }
#@ catch { set ::test_enable_capture_checks [list [binary format H* 74727565]] }
#@ catch { set ::sh_dev_null [list [binary format H* 2f6465762f6e756c6c]] }
#@ catch { set ::view_log_file "" }
#@ catch { set ::hdlin_ignore_textio_constructs [list [binary format H* 54525545]] }
#@ catch { set ::test_design_analyzer_uses_insert_scan [list [binary format H* 74727565]] }
#@ catch { set ::report_capacitance_use_ccs_receiver_model [list [binary format H* 74727565]] }
#@ catch { set ::compile_seqmap_disable_qn_pin_connections [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_isolation_enable_relax_self_dependency_check [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_three_state_name [list [binary format H* 275a27]] }
#@ catch { set ::synlib_hiis_force_on_cells "" }
#@ catch { set ::test_scan_clock_port_naming_style [list [binary format H* 746573745f73632573]] }
#@ catch { set ::verilogout_include_files "" }
#@ catch { set ::mw_hvo_pg_nets [list [binary format H* 74727565]] }
#@ catch { set ::acs_constraint_file_suffix [list [binary format H* 636f6e]] }
#@ catch { set ::hdlin_persistent_macros_filename [list [binary format H* 73796e5f6175746f5f67656e6572617465645f6d6163726f5f66696c652e7376]] }
#@ catch { set ::rc_slew_lower_threshold_pct_rise [list [binary format H* 32302e303030303030]] }
#@ catch { set ::check_design_allow_non_tri_drivers_on_tri_bus [list [binary format H* 74727565]] }
#@ catch { set ::_upf_relax_iso_prot_buff_so_in_const_prop [list [binary format H* 74727565]] }
#@ catch { set ::high_fanout_net_pin_capacitance [list [binary format H* 312e303030303030]] }
#@ catch { set ::vhdllib_pulse_handle [list [binary format H* 7573655f7668646c6c69625f676c697463685f68616e646c65]] }
#@ catch { set ::test_clock_port_naming_style [list [binary format H* 746573745f632573]] }
#@ catch { set ::power_cg_gated_clock_net_naming_style "" }
#@ catch { set ::upf_suppress_message_in_black_box [list [binary format H* 74727565]] }
#@ catch { set ::acs_user_compile_strategy_script_suffix [list [binary format H* 636f6d70696c65]] }
#@ catch { set ::sh_allow_tcl_with_set_app_var_no_message_list "" }
#@ catch { set ::upf_charz_allow_port_punch [list [binary format H* 74727565]] }
#@ catch { set ::mw_hvo_empty_cell_definition [list [binary format H* 66616c7365]] }
#@ catch { set ::lib_pin_using_cap_from_ccs [list [binary format H* 74727565]] }
#@ catch { set ::enable_enhanced_physical_multibit_banking [list [binary format H* 66616c7365]] }
#@ catch { set ::power_opto_extra_high_dynamic_power_effort [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_seqmap_identify_shift_registers [list [binary format H* 74727565]] }
#@ catch { set ::acs_work_dir [list [binary format H* 2f6e6574686f6d652f796b696d3831362f73796e2d6470742f6c6962]] }
#@ catch { set ::view_select_separator [list [binary format H* 20202d2020]] }
#@ catch { set ::test_scandef_stop_skip_last_segment_with_scanout_lockup [list [binary format H* 66616c7365]] }
#@ catch { set ::power_keep_license_after_power_commands [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_pocvm_enable_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::register_duplicate [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_nldm_timing_noise_signoff [list [binary format H* 30]] }
#@ catch { set ::veriloglib_tb_use_sensitization_as_vectors [list [binary format H* 74727565]] }
#@ catch { set ::dc_allow_rtl_pg [list [binary format H* 66616c7365]] }
#@ catch { set ::sdc_runtime_nets_missing_exceptions_fanout_threshold [list [binary format H* 353030]] }
#@ catch { set ::hdlin_sv_interface_only_modules "" }
#@ catch { set ::test_suppress_toggling_instance_name_prefix "" }
#@ catch { set ::write_test_pattern_set_naming_style [list [binary format H* 54435f53796e5f2564]] }
#@ catch { set ::synopsys_program_name [list [binary format H* 64635f7368656c6c]] }
#@ catch { set ::compile_seqmap_enable_output_inversion [list [binary format H* 66616c7365]] }
#@ catch { set ::text_unselect_on_button_press [list [binary format H* 74727565]] }
#@ catch { set ::echo_include_commands [list [binary format H* 74727565]] }
#@ catch { set ::timing_crpr_threshold_ps [list [binary format H* 35]] }
#@ catch { set ::compile_auto_ungroup_override_wlm [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_corner_pad_cells [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_single_bit [list [binary format H* 55534552]] }
#@ catch { set ::report_default_significant_digits [list [binary format H* 2d31]] }
#@ catch { set ::hdlin_interface_port_downto [list [binary format H* 46414c5345]] }
#@ catch { set ::rom_auto_inferring [list [binary format H* 54525545]] }
#@ catch { set ::acs_override_report_suffix [list [binary format H* 7265706f7274]] }
#@ catch { set ::mw_hvo_strip_backslash_before_hiersep [list [binary format H* 74727565]] }
#@ catch { set ::timing_clock_reconvergence_pessimism [list [binary format H* 6e6f726d616c]] }
#@ catch { set ::test_jump_over_bufs_invs [list [binary format H* 74727565]] }
#@ catch { set ::sh_enable_stdout_redirect [list [binary format H* 74727565]] }
#@ catch { set ::derived_upf [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_register_replication [list [binary format H* 64656661756c74]] }
#@ catch { set ::hdlin_upcase_names [list [binary format H* 46414c5345]] }
#@ catch { set ::bus_minus_style [list [binary format H* 2d2564]] }
#@ catch { set ::testsim_print_stats_file [list [binary format H* 74727565]] }
#@ catch { set ::veriloglib_sdf3.0_support [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_name_map "" }
#@ catch { set ::fsm_export_formality_state_info [list [binary format H* 46414c5345]] }
#@ catch { set ::sdc_runtime_fixing_enable [list [binary format H* 74727565]] }
#@ catch { set ::compile_shift_register_max_length [list [binary format H* 30]] }
#@ catch { set ::power_cg_print_enable_conditions_max_terms [list [binary format H* 3130]] }
#@ catch { set ::vhdllib_negative_constraint [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_mux_size_only [list [binary format H* 31]] }
#@ catch { set ::mv_output_upf_line_width [list [binary format H* 30]] }
#@ catch { set ::test_stil_netlist_format [list [binary format H* 6462]] }
#@ catch { set ::mv_insert_level_shifters_on_ideal_nets "" }
#@ catch { set ::synlib_enable_analyze_dw_power [list [binary format H* 30]] }
#@ catch { set ::bsd_max_in_switching_limit [list [binary format H* 3630303030]] }
#@ catch { set ::test_default_strobe [list [binary format H* 34302e30]] }
#@ catch { set ::test_scan_clock_a_port_naming_style [list [binary format H* 746573745f7363612573]] }
#@ catch { set ::verilogout_no_negative_index [list [binary format H* 46414c5345]] }
#@ catch { set ::alib_library_analysis_path [list [binary format H* 2e2f]] }
#@ catch { set ::multi_pass_test_generation [list [binary format H* 66616c7365]] }
#@ catch { set ::view_on_line_doc_cmd "" }
#@ catch { set ::test_ate_sync_cycles [list [binary format H* 31]] }
#@ catch { set ::font_library [list [binary format H* 315f32352e666f6e74]] }
#@ catch { set ::gen_create_netlist_busses [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_unified_rtl_read [list [binary format H* 46414c5345]] }
#@ catch { set ::veriloglib_all_cells_in_one_file [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_budgeted_cstr_suffix [list [binary format H* 636f6e]] }
#@ catch { set ::disable_multicore_resource_checks [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_use_enhanced_capacitance_modeling [list [binary format H* 74727565]] }
#@ catch { set ::link_path [list [binary format H* 202a20796f75725f6c6962726172792e646220]] }
#@ catch { set ::test_fast_feedthrough_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::bit_blasted_bus_linking_naming_styles [list [binary format H* 25735c5b25645c5d202573282564292025735f25645f]] }
#@ catch { set ::upf_name_map_version [list [binary format H* 76312e30]] }
#@ catch { set ::power_report_separate_switching_power [list [binary format H* 66616c7365]] }
#@ catch { set ::sort_outputs [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_sv_union_member_naming [list [binary format H* 46414c5345]] }
#@ catch { set ::sh_source_emits_line_numbers [list [binary format H* 4e6f6e65]] }
#@ catch { set ::timing_scgc_override_library_setup_hold [list [binary format H* 74727565]] }
#@ catch { set ::product [list [binary format H* 44657369676e20566973696f6e]] }
#@ catch { set ::enable_golden_upf [list [binary format H* 66616c7365]] }
#@ catch { set ::abstraction_ignore_percentage [list [binary format H* 3235]] }
#@ catch { set ::test_scan_true_key [list [binary format H* 74]] }
#@ catch { set ::compile_enable_mis_cells_decomposition [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_lower_design_vector [list [binary format H* 54525545]] }
#@ catch { set ::rc_input_threshold_pct_fall [list [binary format H* 35302e303030303030]] }
#@ catch { set ::timing_report_fast_mode [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_add_power_state_21_syntax [list [binary format H* 66616c7365]] }
#@ catch { set ::test_soc_core_wrap_allow_multibit_ioregs [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_wired_and_res_func "" }
#@ catch { set ::ccd_write_script_sdc_add_offset_to_latency [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_generate_naming_style [list [binary format H* 25735f2564]] }
#@ catch { set ::gen_show_created_symbols [list [binary format H* 66616c7365]] }
#@ catch { set ::test_preview_scan_shows_cell_types [list [binary format H* 66616c7365]] }
#@ catch { set ::libsetup_max_auto_opcond_message [list [binary format H* 3130]] }
#@ catch { set ::sdc_runtime_hier_block_pins_top_timing_paths [list [binary format H* 313030]] }
#@ catch { set ::compile_automatic_clock_phase_inference [list [binary format H* 737472696374]] }
#@ catch { set ::golden_upf_report_missing_objects [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_read_ignore_corner_cell [list [binary format H* 74727565]] }
#@ catch { set ::compile_enable_register_merging [list [binary format H* 74727565]] }
#@ catch { set ::check_design_check_multidriven_output_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::test_bsd_version_number [list [binary format H* 30]] }
#@ catch { set ::atpg_test_asynchronous_pins [list [binary format H* 74727565]] }
#@ catch { set ::mv_align_library_pg_pins [list [binary format H* 74727565]] }
#@ catch { set ::view_use_small_cursor [list [binary format H* 74727565]] }
#@ catch { set ::test_scan_link_so_lockup_key [list [binary format H* 6c]] }
#@ catch { set ::sh_new_variable_message_in_proc [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_module_arch_name_splitting [list [binary format H* 46414c5345]] }
#@ catch { set ::test_cc_ir_masked_bits [list [binary format H* 30]] }
#@ catch { set ::mv_upf_enable_forward_reverse_bias_check [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_mux_rp_limit [list [binary format H* 3132387834]] }
#@ catch { set ::timing_report_attributes [list [binary format H* 646f6e745f746f75636820646f6e745f757365206d61705f6f6e6c792073697a655f6f6e6c7920696465616c5f6e657420696e6665617369626c655f7061746873]] }
#@ catch { set ::test_bsd_default_strobe_width [list [binary format H* 302e30]] }
#@ catch { set ::upf_imvc_no_remap_iso [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_drop_conflict_retention_constraint [list [binary format H* 66616c7365]] }
#@ catch { set ::power_cg_all_registers [list [binary format H* 66616c7365]] }
#@ catch { set ::test_mux_constant_si [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_smart_derive_iso_strategy_on_new_control_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::mcmm_high_capacity_effort_level [list [binary format H* 30]] }
#@ catch { set ::veriloglib_tb_compare [list [binary format H* 30]] }
#@ catch { set ::test_mux_constant_so [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_power_domain_boundary_optimization [list [binary format H* 74727565]] }
#@ catch { set ::x11_set_cursor_number [list [binary format H* 2d31]] }
#@ catch { set ::timing_library_derate_is_scenario_specific [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_sv_enable_rtl_attributes [list [binary format H* 46414c5345]] }
#@ catch { set ::acs_ddc_suffix [list [binary format H* 646463]] }
#@ catch { set ::hdlin_check_input_netlist [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_failsafe_fsm [list [binary format H* 46414c5345]] }
#@ catch { set ::test_count_occ_chain_in_chain_count [list [binary format H* 66616c7365]] }
#@ catch { set ::dc_allow_rtl_pg_to_analog_pins [list [binary format H* 74727565]] }
#@ catch { set ::tcl_patchLevel [list [binary format H* 382e362e3131]] }
#@ catch { set ::mw_hvo_pad_filler_cells [list [binary format H* 74727565]] }
#@ catch { set ::test_bsd_part_number [list [binary format H* 30]] }
#@ catch { set ::upf_allow_or_operator_in_add_power_state_supply_expr [list [binary format H* 66616c7365]] }
#@ catch { set ::test_output_wrapper_chain_naming_style "" }
#@ catch { set ::vhdllib_insert_timing [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_one_name [list [binary format H* 273127]] }
#@ catch { set ::ltl_obstruction_type [list [binary format H* 706c6163656d656e745f6f6e6c79]] }
#@ catch { set ::view_set_cursor_area [list [binary format H* 35]] }
#@ catch { set ::vhdlout_zero_name [list [binary format H* 273027]] }
#@ catch { set ::enable_cell_based_verilog_reader [list [binary format H* 66616c7365]] }
#@ catch { set ::power_cg_auto_identify [list [binary format H* 66616c7365]] }
#@ catch { set ::write_converted_tf_syntax [list [binary format H* 66616c7365]] }
#@ catch { set ::use_port_name_for_oscs [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_obsolete_is_error [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_slack_driven_buffering [list [binary format H* 66616c7365]] }
#@ catch { set ::insert_dft_clean_up [list [binary format H* 74727565]] }
#@ catch { set ::power_preserve_rtl_hier_names [list [binary format H* 66616c7365]] }
#@ catch { set ::lc [list [binary format H* 4e4c535f4c414e47]] }
#@ catch { set ::acs_preferred_target_compiler "" }
#@ catch { set ::acs_sverilog_extensions [list [binary format H* 2e7376]] }
#@ catch { set ::ungroup_keep_original_design [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_enable_hier_map [list [binary format H* 46414c5345]] }
#@ catch { set ::upf_print_voltages_with_states [list [binary format H* 66616c7365]] }
#@ catch { set ::write_test_include_scan_cell_info [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_package_naming_style [list [binary format H* 434f4e565f5041434b5f2564]] }
#@ catch { set ::write_test_max_scan_patterns [list [binary format H* 30]] }
#@ catch { set ::hdlin_infer_multibit [list [binary format H* 64656661756c745f6e6f6e65]] }
#@ catch { set ::change_names_dont_change_bus_members [list [binary format H* 66616c7365]] }
#@ catch { set ::view_write_file_suffix [list [binary format H* 6764622064622073646220646f20656469662065716e20666e63206c7369204e4554206e6574656420706c612073742074646c207620766864207668646c20786e66]] }
#@ catch { set ::hdlin_ff_always_sync_set_reset [list [binary format H* 46414c5345]] }
#@ catch { set ::check_design_allow_unknown_wired_logic_type [list [binary format H* 74727565]] }
#@ catch { set ::sdc_runtime_port_clock_constraint_threshold [list [binary format H* 3230]] }
#@ catch { set ::optimize_area_ignore_path_group_weights [list [binary format H* 74727565]] }
#@ catch { set ::command [list [binary format H* 636170747572655f716f725f64617461]] }
#@ catch { set ::cache_read "" }
#@ catch { set ::hdl_keep_licenses [list [binary format H* 74727565]] }
#@ catch { set ::compile_ultra_ungroup_small_hierarchies [list [binary format H* 74727565]] }
#@ catch { set ::gen_single_osc_per_name [list [binary format H* 66616c7365]] }
#@ catch { set ::db_load_ccs_data [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_auto_sdp_verbose [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_enable_register_merging_with_exceptions [list [binary format H* 74727565]] }
#@ catch { set ::err [list [binary format H* 312e37]] }
#@ catch { set ::disable_case_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_infer_function_local_latches [list [binary format H* 46414c5345]] }
#@ catch { set ::mw_read_ignore_pad_cell [list [binary format H* 74727565]] }
#@ catch { set ::vhdllib_logical_name "" }
#@ catch { set ::test_stil_max_line_length [list [binary format H* 3732]] }
#@ catch { set ::test_input_wrapper_chain_naming_style "" }
#@ catch { set ::upf_write_only_rtlpg_to_pg_netlist [list [binary format H* 66616c7365]] }
#@ catch { set ::db_load_ccs_noise_data [list [binary format H* 66616c7365]] }
#@ catch { set ::power_same_switching_activity_on_connected_objects [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_enable_configurations [list [binary format H* 46414c5345]] }
#@ catch { set ::test_bsd_optimize_control_cell [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_help_shows_group_overview [list [binary format H* 74727565]] }
#@ catch { set ::rc_output_threshold_pct_rise [list [binary format H* 35302e303030303030]] }
#@ catch { set ::symbol_library [list [binary format H* 796f75725f6c6962726172792e736462]] }
#@ catch { set ::vhdlout_top_configuration_entity_name [list [binary format H* 45]] }
#@ catch { set ::mw_read_ignore_unconnected_cell [list [binary format H* 74727565]] }
#@ catch { set ::sh_auto_sdp_commands "" }
#@ catch { set ::ctldb_use_old_prot_flow [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_always_fsm_complete [list [binary format H* 46414c5345]] }
#@ catch { set ::test_bsd_dead_cycle_after_update_dr [list [binary format H* 30]] }
#@ catch { set ::acs_hdl_source "" }
#@ catch { set ::tcl_precision [list [binary format H* 3132]] }
#@ catch { set ::sdc_runtime_paths_missing_inter_clock_constraints [list [binary format H* 35]] }
#@ catch { set ::optimize_reg_add_path_groups [list [binary format H* 66616c7365]] }
#@ catch { set ::write_test_new_translation_engine [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_skip_ao_check_for_els_input [list [binary format H* 74727565]] }
#@ catch { set ::test_set_svf_print_exclude_existing_dft_se_alike [list [binary format H* 66616c7365]] }
#@ catch { set ::power_cg_inherit_timing_exceptions [list [binary format H* 66616c7365]] }
#@ catch { set ::rc_slew_upper_threshold_pct_fall [list [binary format H* 38302e303030303030]] }
#@ catch { set ::sh_new_variable_message_in_script [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_qor_report_suffix [list [binary format H* 716f72]] }
#@ catch { set ::compile_keep_original_for_external_references [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_segment_key [list [binary format H* 73]] }
#@ catch { set ::compile_retime_license_behavior [list [binary format H* 77616974]] }
#@ catch { set ::upf_iso_filter_elements_with_applies_to [list [binary format H* 454e41424c45]] }
#@ catch { set ::compile_dont_touch_annotated_cell_during_inplace_opt [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_elaborate_black_box_all_except "" }
#@ catch { set ::mw_pgconn_cell_inst "" }
#@ catch { set ::default_port_connection_class [list [binary format H* 756e6976657273616c]] }
#@ catch { set ::xt_filter_logic_constant_aggressors [list [binary format H* 74727565]] }
#@ catch { set ::sdc_runtime_analysis_enable [list [binary format H* 66616c7365]] }
#@ catch { set ::sdfout_time_scale [list [binary format H* 312e30]] }
#@ catch { set ::test_default_min_fault_coverage [list [binary format H* 3935]] }
#@ catch { set ::power_low_power_placement [list [binary format H* 66616c7365]] }
#@ catch { set ::lbo_cells_in_regions [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_ff_always_async_set_reset [list [binary format H* 54525545]] }
#@ catch { set ::acs_area_report_suffix [list [binary format H* 61726561]] }
#@ catch { set ::mw_cel_as_escaped [list [binary format H* 74727565]] }
#@ catch { set ::view_error_window_count [list [binary format H* 36]] }
#@ catch { set ::mw_hdl_stop_at_FRAM_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_top_configuration_name [list [binary format H* 4346475f54425f45]] }
#@ catch { set ::bus_multiple_name_separator_style [list [binary format H* 2c2c]] }
#@ catch { set ::compile_auto_ungroup_count_leaf_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_create_implicit_supply_sets [list [binary format H* 74727565]] }
#@ catch { set ::upf_write_highest_upf_version [list [binary format H* 66616c7365]] }
#@ catch { set ::power_enable_one_pass_power_gating [list [binary format H* 66616c7365]] }
#@ catch { set ::view_command_log_file [list [binary format H* 2e2f766965775f636f6d6d616e642e6c6f67]] }
#@ catch { set ::sdfout_write_to_output [list [binary format H* 66616c7365]] }
#@ catch { set ::test_protocol_add_cycle [list [binary format H* 74727565]] }
#@ catch { set ::level_shifter_naming_prefix "" }
#@ catch { set ::synlib_dwhomeip "" }
#@ catch { set ::acs_attr [list [binary format H* 4f7074696d697a6174696f6e5072696f726974696573205072657365727665426f756e64617269657320436f6d70696c6556657269667920546573745265616479436f6d70696c65204d6178417265612043616e466c617474656e2046756c6c436f6d70696c6520496e6372656d656e74616c436f6d70696c6520426f756e64617279436f6d70696c6520556c7472614f7074696d697a6174696f6e204175746f556e67726f757020557365546f70416c6c506174687320436f6d70696c65556c74726120546172676574436f6d70696c6572]] }
#@ catch { set ::mw_site_name_mapping "" }
#@ catch { set ::compile_inbound_cell_optimization [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_dont_create_dummy_nets [list [binary format H* 46414c5345]] }
#@ catch { set ::is_qt4 [list [binary format H* 30]] }
#@ catch { set ::gen_max_compound_name_length [list [binary format H* 323536]] }
#@ catch { set ::dct_placement_ignore_scan [list [binary format H* 66616c7365]] }
#@ catch { set ::test_non_scan_clock_port_naming_style [list [binary format H* 746573745f6e73635f2573]] }
#@ catch { set ::systemcout_levelize [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_enable_relative_placement [list [binary format H* 7262]] }
#@ catch { set ::_upf_apply_retention_attribute_on_non_retention_macro [list [binary format H* 66616c7365]] }
#@ catch { set ::clock_arnoldi_dbg_file "" }
#@ catch { set ::upf_charz_enable_supply_port_punching [list [binary format H* 74727565]] }
#@ catch { set ::timing_check_defaults [list [binary format H* 67656e6572617465645f636c6f636b206c6f6f7073206e6f5f696e7075745f64656c617920756e636f6e73747261696e65645f656e64706f696e74732070756c73655f636c6f636b5f63656c6c5f74797065206e6f5f64726976696e675f63656c6c207061727469616c5f696e7075745f64656c6179]] }
#@ catch { set ::upf_use_driver_receiver_for_io_voltages [list [binary format H* 74727565]] }
#@ catch { set ::acs_make_exec [list [binary format H* 676d616b65]] }
#@ catch { set ::default_output_delay [list [binary format H* 3330]] }
#@ catch { set ::si_xtalk_composite_aggr_noise_peak_ratio [list [binary format H* 302e3031]] }
#@ catch { set ::test_cc_ir_value_of_masked_bits [list [binary format H* 30]] }
#@ catch { set ::acs_timing_report_suffix [list [binary format H* 74696d]] }
#@ catch { set ::gen_match_ripper_wire_widths [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_in_port_naming_style [list [binary format H* 746573745f736925732573]] }
#@ catch { set ::test_rtldrc_latch_check_style [list [binary format H* 64656661756c74]] }
#@ catch { set ::compile_enable_min_delay_fixing [list [binary format H* 66616c7365]] }
#@ catch { set ::test_capture_clock_skew [list [binary format H* 736d616c6c5f736b6577]] }
#@ catch { set ::power_do_not_size_icg_cells [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_strict_verilog_reader [list [binary format H* 46414c5345]] }
#@ catch { set ::do_operand_isolation [list [binary format H* 66616c7365]] }
#@ catch { set ::view_command_win_max_lines [list [binary format H* 31303030]] }
#@ catch { set ::verilogout_no_tri [list [binary format H* 66616c7365]] }
#@ catch { set ::test_bsd_default_delay [list [binary format H* 302e30]] }
#@ catch { set ::compile_optimize_netlist_area [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_verilog_extensions [list [binary format H* 2e76]] }
#@ catch { set ::when_analysis_without_case_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_netlist_unloaded_signals [list [binary format H* 46414c5345]] }
#@ catch { set ::__err [list [binary format H* 63616e2774207265616420223a3a656e76284c4d435f484f4d4529223a206e6f2073756368207661726961626c65]] }
#@ catch { set ::timing_enable_non_sequential_checks [list [binary format H* 66616c7365]] }
#@ catch { set ::lib_cell_using_delay_from_ccs [list [binary format H* 74727565]] }
#@ catch { set ::test_shared_codec_io_architecture [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_write_attributes [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_intermediate_file_method [list [binary format H* 6c6567616379]] }
#@ catch { set ::view_extend_thick_lines [list [binary format H* 74727565]] }
#@ catch { set ::insert_test_design_naming_style [list [binary format H* 25735f746573745f2564]] }
#@ catch { set ::sdfout_min_fall_cell_delay [list [binary format H* 302e]] }
#@ catch { set ::sdc_runtime_tightly_constrained_same_clock_path_groups [list [binary format H* 3530]] }
#@ catch { set ::html_log_filename [list [binary format H* 64656661756c742e68746d6c]] }
#@ catch { set ::hdl_preferred_license "" }
#@ catch { set ::sh_allow_tcl_with_set_app_var [list [binary format H* 74727565]] }
#@ catch { set ::compile_top_acs_partition [list [binary format H* 66616c7365]] }
#@ catch { set ::power_enable_minpower [list [binary format H* 46414c5345]] }
#@ catch { set ::veriloglib_sdf_edge [list [binary format H* 74727565]] }
#@ catch { set ::upf_proceed_on_bias_rail_order_error [list [binary format H* 66616c7365]] }
#@ catch { set ::nglc_replay_tcl_file [list [binary format H* 6e676c635f7368656c6c5f636f6d6d616e642e74636c]] }
#@ catch { set ::view_busy_during_selection [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_autoread_sverilog_extensions [list [binary format H* 2e7376202e73766572696c6f67]] }
#@ catch { set ::upf_suppress_etm_model_checking [list [binary format H* 66616c7365]] }
#@ catch { set ::template_parameter_style [list [binary format H* 25732564]] }
#@ catch { set ::acs_log_file_suffix [list [binary format H* 6c6f67]] }
#@ catch { set ::check_design_allow_multiply_driven_nets_by_inputs_and_outputs [list [binary format H* 66616c7365]] }
#@ catch { set ::ignore_tf_error [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_latch_always_async_set_reset [list [binary format H* 46414c5345]] }
#@ catch { set ::html_log_enable [list [binary format H* 66616c7365]] }
#@ catch { set ::power_default_toggle_rate [list [binary format H* 302e31]] }
#@ catch { set ::sheet_sizes "" }
#@ catch { set ::hdlin_autoread_vhdl_extensions [list [binary format H* 2e766864202e7668646c]] }
#@ catch { set ::auto_insert_level_shifters_on_clocks "" }
#@ catch { set ::disable_library_transition_degradation [list [binary format H* 66616c7365]] }
#@ catch { set ::power_scale_internal_arc [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_bit_vector_type [list [binary format H* 7374645f6c6f6769635f766563746f72]] }
#@ catch { set ::compile_allow_dw_hierarchical_inverter_opt [list [binary format H* 66616c7365]] }
#@ catch { set ::budget_generate_critical_range [list [binary format H* 66616c7365]] }
#@ catch { set ::fanin_fanout_trace_arcs [list [binary format H* 74696d696e67]] }
#@ catch { set ::hdlin_vhdl93_concat [list [binary format H* 54525545]] }
#@ catch { set ::compile_restructure_sync_set_reset [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_exclude_extensions "" }
#@ catch { set ::hdlin_check_no_latch [list [binary format H* 46414c5345]] }
#@ catch { set ::gen_dont_show_single_bit_busses [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_autopart_max_percent [list [binary format H* 302e30]] }
#@ catch { set ::hdlin_mux_for_array_read_sparseness_limit [list [binary format H* 3930]] }
#@ catch { set ::si_xtalk_composite_aggr_quantile_high_pct [list [binary format H* 39392e3733]] }
#@ catch { set ::tcl_interactive [list [binary format H* 30]] }
#@ catch { set ::check_design_allow_inconsistent_input_port [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_write_entity [list [binary format H* 54525545]] }
#@ catch { set ::view_report_append [list [binary format H* 74727565]] }
#@ catch { set ::compile_report_on_unmapped_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::optimize_netlist_enable_state_reachability [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_enable_elaborate_update [list [binary format H* 74727565]] }
#@ catch { set ::template_naming_style [list [binary format H* 25735f2570]] }
#@ catch { set ::simplified_verification_mode_allow_retiming [list [binary format H* 46414c5345]] }
#@ catch { set ::power_cg_balance_stages [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_delete_unloaded_sequential_cells [list [binary format H* 74727565]] }
#@ catch { set ::test_isolate_hier_scan_out [list [binary format H* 30]] }
#@ catch { set ::test_keep_connected_scan_en [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_instances_in_report_net [list [binary format H* 74727565]] }
#@ catch { set ::mv_output_enforce_simple_names [list [binary format H* 74727565]] }
#@ catch { set ::auto_link_options [list [binary format H* 2d616c6c]] }
#@ catch { set ::cts_clock_source_is_exclude_pin [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_sv_packages [list [binary format H* 646f6e745f636861696e]] }
#@ catch { set ::hdlin_enable_upf_compatible_naming [list [binary format H* 46414c5345]] }
#@ catch { set ::test_user_test_data_register_naming_style [list [binary format H* 555444522564]] }
#@ catch { set ::power_cg_module_naming_style "" }
#@ catch { set ::test_scan_link_wire_key [list [binary format H* 77]] }
#@ catch { set ::vhdlout_follow_vector_direction [list [binary format H* 54525545]] }
#@ catch { set ::view_use_x_routines [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_write_architecture [list [binary format H* 54525545]] }
#@ catch { set ::timing_enable_through_paths [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_auto_ungroup_area_num_cells [list [binary format H* 3330]] }
#@ catch { set ::compile_optimize_netlist_area_in_incremental [list [binary format H* 64656661756c74]] }
#@ catch { set ::bit_blasted_bus_linking_order [list [binary format H* 7265666572656e6365]] }
#@ catch { set ::all_registers_include_icg [list [binary format H* 66616c7365]] }
#@ catch { set ::sdc_runtime_top_fanout_nets_missing_exceptions [list [binary format H* 313030]] }
#@ catch { set ::spg_high_effort_mux_area_structuring [list [binary format H* 74727565]] }
#@ catch { set ::view_draw_text_breakpoint [list [binary format H* 302e3031]] }
#@ catch { set ::veriloglib_delay_signal_naming_style "" }
#@ catch { set ::compile_register_replication_do_size_only [list [binary format H* 74727565]] }
#@ catch { set ::compile_enable_multibit_rewiring_in_incremental [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_create_netlist_from_CEL [list [binary format H* 66616c7365]] }
#@ catch { set ::tcl_version [list [binary format H* 382e36]] }
#@ catch { set ::upf_isols_allow_instances_in_elements [list [binary format H* 74727565]] }
#@ catch { set ::test_setup_additional_clock_pulse [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_use_driver_arc_transition_at_clock_source [list [binary format H* 74727565]] }
#@ catch { set ::upf_relax_target_library_subset_for_pm_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_preserve_subdesign_interfaces [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_v2005_replication_semantics [list [binary format H* 54525545]] }
#@ catch { set ::compile_top_all_paths [list [binary format H* 66616c7365]] }
#@ catch { set ::register_replication_naming_style [list [binary format H* 25735f7265702564]] }
#@ catch { set ::init_path [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f73796e]] }
#@ catch { set ::power_cg_enable_alternative_algorithm [list [binary format H* 66616c7365]] }
#@ catch { set ::exit_delete_command_log_file [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_enable_port_naming_style [list [binary format H* 746573745f73652573]] }
#@ catch { set ::enable_keep_signal [list [binary format H* 66616c7365]] }
#@ catch { set ::power_cg_print_enable_conditions [list [binary format H* 66616c7365]] }
#@ catch { set ::gen_open_name_prefix [list [binary format H* 4f70656e]] }
#@ catch { set ::timing_report_union_tns [list [binary format H* 74727565]] }
#@ catch { set ::upf_extension [list [binary format H* 74727565]] }
#@ catch { set ::tcl_pkgPath [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f6c69622f74636c382e36]] }
#@ catch { set ::db_load_ccs_power_data [list [binary format H* 66616c7365]] }
#@ catch { set ::libgen_max_differences [list [binary format H* 2d31]] }
#@ catch { set ::site_info_file [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f61646d696e2f6c6963656e73652f736974655f696e666f]] }
#@ catch { set ::search_path [list [binary format H* 2e202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f6c69627261726965732f73796e202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f64772f73796e5f766572202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f64772f73696d5f766572]] }
#@ catch { set ::vhdllib_timing_checks [list [binary format H* 74727565]] }
#@ catch { set ::mv_allow_multiple_power_domain_in_voltage_area [list [binary format H* 66616c7365]] }
#@ catch { set ::preserve_collections_in_compile [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_while_loop_iterations [list [binary format H* 34303936]] }
#@ catch { set ::mw_power_port "" }
#@ catch { set ::current_instance "" }
#@ catch { set ::lib_use_thresholds_per_pin [list [binary format H* 74727565]] }
#@ catch { set ::test_bsd_allow_tolerable_violations [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_submit_log_uses_o_option [list [binary format H* 74727565]] }
#@ catch { set ::cache_write_info [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_sv_tokens [list [binary format H* 46414c5345]] }
#@ catch { set ::mw_disable_escape_char [list [binary format H* 74727565]] }
#@ catch { set ::list_of_file_types [list [binary format H* 766572696c6f6728762920207668646c28766864292020676c6f62616c5f6373747228636f6e292020706173735f6373747228636f6e292020757365725f6f766572726964655f636f6e73747261696e7428636f6e292020757365725f6f766572726964655f73637269707428736372292020757365725f6275646765745f73637269707428292020757365725f7265706f72745f736372697074287265706f7274292020757365725f636f6d70696c655f73747261746567795f73637269707428636f6d70696c65292020757365725f636f6d70696c655f7363726970742874636c292020706173735f636f6d70696c655f736372697074286175746f736372292020656c61625f6462286462292020656c61625f646463286464632920206c69625f64622864622920207072655f6462286462292020706f73745f64622864622920207072655f64646328646463292020706f73745f6464632864646329202073766628737666292020676c6f62616c5f6c6f67286c6f67292020706173735f6c6f67286c6f672920206d616b6566696c65282920206f632e74636c286f632e74636c292020637374722e74636c28637374722e74636c292020706173735f617265615f7265706f72742861726561292020706173735f74696d696e675f7265706f72742874696d292020706173735f716f725f7265706f727428716f72292020706173735f637374725f7265706f72742863737472292020676c6f62616c5f7265706f727428292020656e762829]] }
#@ catch { set ::power_cg_iscgs_enable [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_enable_multiple_clocks_per_reg [list [binary format H* 74727565]] }
#@ catch { set ::timing_use_clock_specific_transition [list [binary format H* 74727565]] }
#@ catch { set ::sh_deprecated_is_error [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_pm_data_net_force_scalar [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_upf_enable_reverse_bias_check [list [binary format H* 66616c7365]] }
#@ catch { set ::lc_enable_legacy_library_compiler [list [binary format H* 66616c7365]] }
#@ catch { set ::default_schematic_options [list [binary format H* 2d73697a6520696e66696e697465]] }
#@ catch { set ::test_point_keep_hierarchy [list [binary format H* 66616c7365]] }
#@ catch { set ::hlo_resource_allocation [list [binary format H* 636f6e73747261696e745f64726976656e]] }
#@ catch { set ::gui_start_option_no_windows [list [binary format H* 30]] }
#@ catch { set ::case_analysis_with_logic_constants [list [binary format H* 74727565]] }
#@ catch { set ::var_mux_mbm [list [binary format H* 54525545]] }
#@ catch { set ::mv_allow_va_beyond_core_area [list [binary format H* 66616c7365]] }
#@ catch { set ::link_allow_pin_name_synonym [list [binary format H* 74727565]] }
#@ catch { set ::default_name_rules "" }
#@ catch { set ::nglc_keep_nglc_temp_files [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_vrlg_std [list [binary format H* 32303035]] }
#@ catch { set ::vhdllib_timing_xgen [list [binary format H* 66616c7365]] }
#@ catch { set ::port_complement_naming_style [list [binary format H* 25735f424152]] }
#@ catch { set ::inherit_parent_dont_touch [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_special_level_shifter_naming [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_allow_unpacked_array_concat_on_port [list [binary format H* 66616c7365]] }
#@ catch { set ::atpg_bidirect_output_only [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_enable_assertions [list [binary format H* 46414c5345]] }
#@ catch { set ::vhdlout_unknown_name [list [binary format H* 275827]] }
#@ catch { set ::ccl_enable_always [list [binary format H* 66616c7365]] }
#@ catch { set ::view_disable_output [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_enable_ieee_1735_support [list [binary format H* 74727565]] }
#@ catch { set ::sh_enable_page_mode [list [binary format H* 74727565]] }
#@ catch { set ::compile_final_drc_fix [list [binary format H* 6e6f6e65]] }
#@ catch { set ::compile_instance_name_prefix [list [binary format H* 55]] }
#@ catch { set ::compile_update_annotated_delays_during_inplace_opt [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_mux_oversize_ratio [list [binary format H* 313030]] }
#@ catch { set ::sdfout_allow_non_positive_constraints [list [binary format H* 66616c7365]] }
#@ catch { set ::physopt_ignore_lpin_fanout [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_hold_reduce_cell_count [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_create_wire_load_table [list [binary format H* 66616c7365]] }
#@ catch { set ::view_select_default_message "" }
#@ catch { set ::check_error_list [list [binary format H* 434d442d30303420434d442d30303620434d442d30303720434d442d30303820434d442d30303920434d442d30313020434d442d30313120434d442d30313220434d442d30313420434d442d30313520434d442d30313620434d442d30313920434d442d30323620434d442d30333120434d442d3033372044422d3120444353482d3131204445532d303031204143532d3139332046494c452d312046494c452d322046494c452d332046494c452d34204c494e4b2d37204c494e542d37204c494e542d3230204c4e4b2d303233204f50542d313030204f50542d313031204f50542d313032204f50542d313134204f50542d313234204f50542d313237204f50542d313238204f50542d313535204f50542d313537204f50542d313831204f50542d3436322055492d31312055492d31342055492d31352055492d31362055492d31372055492d31392055492d32302055492d32312055492d32322055492d32332055492d34302055492d3431205549442d34205549442d36205549442d37205549442d38205549442d39205549442d3133205549442d3134205549442d3135205549442d3139205549442d3230205549442d3235205549442d3237205549442d3238205549442d3239205549442d3330205549442d3332205549442d3538205549442d3837205549442d313033205549442d313039205549442d323730205549442d323732205549442d343033205549442d343430205549442d3434342055494f2d322055494f2d332055494f2d342055494f2d32352055494f2d36352055494f2d36362055494f2d37352055494f2d39342055494f2d39352045514e2d362045514e2d31312045514e2d31352045514e2d31362045514e2d31382045514e2d3230]] }
#@ catch { set ::mv_input_enforce_simple_names [list [binary format H* 74727565]] }
#@ catch { set ::test_dedicated_subdesign_scan_outs [list [binary format H* 66616c7365]] }
#@ catch { set ::write_test_max_cycles [list [binary format H* 30]] }
#@ catch { set ::power_cg_permit_opposite_edge_icg [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_tic_tic_discards_whitespace [list [binary format H* 46414c5345]] }
#@ catch { set ::vhdllib_timing_mesg [list [binary format H* 74727565]] }
#@ catch { set ::sdf_enable_cond_start_end [list [binary format H* 66616c7365]] }
#@ catch { set ::uniquify_keep_original_design [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_lic_wait [list [binary format H* 30]] }
#@ catch { set ::test_default_delay [list [binary format H* 302e30]] }
#@ catch { set ::compile_enable_total_power_optimization [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_make_args [list [binary format H* 736574206163735f6d616b655f61726773]] }
#@ catch { set ::rc_input_threshold_pct_rise [list [binary format H* 35302e303030303030]] }
#@ catch { set ::compile_ultra_ungroup_dw [list [binary format H* 54525545]] }
#@ catch { set ::mw_design_library "" }
#@ catch { set ::upf_enable_mv_merge_clone [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_output_upf_line_indent [list [binary format H* 32]] }
#@ catch { set ::hdlin_enable_persistent_macros [list [binary format H* 46414c5345]] }
#@ catch { set ::upf_disable_b2b_iso_nor_optimization_strategies [list [binary format H* 2a]] }
#@ catch { set ::verilogout_unconnected_prefix [list [binary format H* 53594e4f505359535f554e434f4e4e45435445445f]] }
#@ catch { set ::hdlin_auto_save_templates [list [binary format H* 46414c5345]] }
#@ catch { set ::sdfout_min_rise_net_delay [list [binary format H* 302e]] }
#@ catch { set ::synlib_dont_get_license "" }
#@ catch { set ::test_disable_find_best_scan_out [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_enable_relaxed_charz [list [binary format H* 74727565]] }
#@ catch { set ::verilogout_ignore_case [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_write_components [list [binary format H* 54525545]] }
#@ catch { set ::power_enable_power_gating [list [binary format H* 66616c7365]] }
#@ catch { set ::sdc_runtime_analysis_log_file [list [binary format H* 7364635f72756e74696d652e6c6f67]] }
#@ catch { set ::text_print_command [list [binary format H* 6c7072202d506c77]] }
#@ catch { set ::disable_conditional_mode_analysis [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_max_parallel_computations [list [binary format H* 30]] }
#@ catch { set ::DW_lp_op_iso_mode [list [binary format H* 4e4f4e45]] }
#@ catch { set ::bus_naming_style [list [binary format H* 25735b25645d]] }
#@ catch { set ::hdlin_presto_cell_name_prefix [list [binary format H* 43]] }
#@ catch { set ::hdlout_internal_busses [list [binary format H* 46414c5345]] }
#@ catch { set ::vhdlout_unconnected_pin_prefix [list [binary format H* 6e]] }
#@ catch { set ::timing_enable_normalized_slack [list [binary format H* 66616c7365]] }
#@ catch { set ::icc2_link_processes_inherit_parent_process_group [list [binary format H* 66616c7365]] }
#@ catch { set ::auto_oldpath "" }
#@ catch { set ::vhdlout_wired_or_res_func "" }
#@ catch { set ::vhdlout_use_packages [list [binary format H* 494545452e7374645f6c6f6769635f31313634]] }
#@ catch { set ::auto_insert_level_shifters [list [binary format H* 74727565]] }
#@ catch { set ::sdc_write_unambiguous_names [list [binary format H* 74727565]] }
#@ catch { set ::acs_vhdl_extensions [list [binary format H* 2e766864]] }
#@ catch { set ::hdlin_field_naming_style "" }
#@ catch { set ::template_separator_style [list [binary format H* 5f]] }
#@ catch { set ::text_editor_command [list [binary format H* 787465726d202d666e2038783133202d652076692025732026]] }
#@ catch { set ::vhdllib_architecture [list [binary format H* 564954414c]] }
#@ catch { set ::hdlin_interface_port_ABI [list [binary format H* 32]] }
#@ catch { set ::gen_open_name_postfix "" }
#@ catch { set ::seqmap_prefer_registers_with_multibit_equivalent [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_verilog_netlist_reader [list [binary format H* 74727565]] }
#@ catch { set ::nglc_is_symbol_file [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_max_normalization_cycles [list [binary format H* 34]] }
#@ catch { set ::enable_fast_mode [list [binary format H* 46414c5345]] }
#@ catch { set ::write_test_round_timing_values [list [binary format H* 74727565]] }
#@ catch { set ::compile_enable_async_mux_mapping [list [binary format H* 74727565]] }
#@ catch { set ::enable_slew_degradation [list [binary format H* 74727565]] }
#@ catch { set ::mv_upf_enable_forward_bias_check [list [binary format H* 66616c7365]] }
#@ catch { set ::_acs_html_filename [list [binary format H* 526573756c74732e68746d6c]] }
#@ catch { set ::link_allow_physical_variant_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_out_port_naming_style [list [binary format H* 746573745f736f25732573]] }
#@ catch { set ::find_converts_name_lists [list [binary format H* 66616c7365]] }
#@ catch { set ::exit_delete_filename_log_file [list [binary format H* 74727565]] }
#@ catch { set ::compile_seqmap_identify_shift_registers_with_synchronous_logic_ascii [list [binary format H* 66616c7365]] }
#@ catch { set ::get_attribute_float_decimal_places [list [binary format H* 36]] }
#@ catch { set ::initial_target_library "" }
#@ catch { set ::compile_assume_fully_decoded_three_state_busses [list [binary format H* 66616c7365]] }
#@ catch { set ::simplified_verification_mode [list [binary format H* 46414c5345]] }
#@ catch { set ::new_idn_switch [list [binary format H* 74727565]] }
#@ catch { set ::found_arch_apollo [list [binary format H* 30]] }
#@ catch { set ::upf_allow_refer_before_define [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_upf_tracking [list [binary format H* 74727565]] }
#@ catch { set ::hdlin_reporting_level [list [binary format H* 6261736963]] }
#@ catch { set ::hdlin_preserve_sequential [list [binary format H* 6e6f6e65]] }
#@ catch { set ::test_scan_chain_naming_style "" }
#@ catch { set ::acs_user_budgeting_script [list [binary format H* 6275646765742e736372]] }
#@ catch { set ::vhdllib_logic_system [list [binary format H* 696565652d31313634]] }
#@ catch { set ::annotation_control [list [binary format H* 3634]] }
#@ catch { set ::sh_script_stop_severity [list [binary format H* 4e6f6e65]] }
#@ catch { set ::test_write_four_cycle_stil_protocol [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_ignore_ghm_errors [list [binary format H* 66616c7365]] }
#@ catch { set ::synlib_preferred_ff_chains "" }
#@ catch { set ::hdlin_presto_net_name_prefix [list [binary format H* 4e]] }
#@ catch { set ::spg_enhanced_timing_model [list [binary format H* 66616c7365]] }
#@ catch { set ::bus_range_separator_style [list [binary format H* 3a]] }
#@ catch { set ::filter_collection_extended_syntax [list [binary format H* 74727565]] }
#@ catch { set ::vhdllib_cell_name_map_file "" }
#@ catch { set ::verilogout_higher_designs_first [list [binary format H* 46414c5345]] }
#@ catch { set ::compile_print_crossprobe_info_with_seqmap_messages [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_must_not_dump_master_names "" }
#@ catch { set ::synlib_iis_use_netlist [list [binary format H* 46414c5345]] }
#@ catch { set ::enable_keep_signal_dt_net [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_clock_b_port_naming_style [list [binary format H* 746573745f7363622573]] }
#@ catch { set ::rc_slew_upper_threshold_pct_rise [list [binary format H* 38302e303030303030]] }
#@ catch { set ::si_ccs_use_gate_level_simulation [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_compile_script_suffix [list [binary format H* 6175746f736372]] }
#@ catch { set ::test_allow_clock_reconvergence [list [binary format H* 74727565]] }
#@ catch { set ::nglc_search_path2 [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f6c632f6c61746573742f6c696e757836342f6c632f62696e2f6c63325f7368656c6c5f65786563]] }
#@ catch { set ::upf_report_isolation_matching [list [binary format H* 66616c7365]] }
#@ catch { set ::power_cg_flatten [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_seqmap_propagate_constants [list [binary format H* 74727565]] }
#@ catch { set ::filename_log_file [list [binary format H* 66696c656e616d65732e6c6f67]] }
#@ catch { set ::hdlin_vhdl_mixed_language_instantiation [list [binary format H* 46414c5345]] }
#@ catch { set ::gui_auto_start [list [binary format H* 30]] }
#@ catch { set ::tcl_prompt1 [list [binary format H* 6563686f202d6e202264635f7368656c6c3e2022]] }
#@ catch { set ::upf_charz_max_srsn_messages [list [binary format H* 3130]] }
#@ catch { set ::mw_cell_name "" }
#@ catch { set ::test_allow_internal_pins_in_hierarchical_flow [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_phys_lib_during_elab [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_enable_hier_naming [list [binary format H* 46414c5345]] }
#@ catch { set ::nglc_search_path [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f6c632f6c61746573742f6c696e757836342f6c632f62696e2f6c635f7368656c6c5f65786563]] }
#@ catch { set ::test_bsd_synthesis_gated_tck [list [binary format H* 66616c7365]] }
#@ catch { set ::test_simulation_library "" }
#@ catch { set ::test_wrapper_new_wrp_clock_timing "" }
#@ catch { set ::power_fix_sdpd_annotation [list [binary format H* 74727565]] }
#@ catch { set ::acs_autopart_max_area [list [binary format H* 302e30]] }
#@ catch { set ::mw_current_design "" }
#@ catch { set ::rc_slew_derate_from_library [list [binary format H* 312e303030303030]] }
#@ catch { set ::pdefout_diff_original [list [binary format H* 54525545]] }
#@ catch { set ::rc_degrade_min_slew_when_rd_less_than_rnet [list [binary format H* 66616c7365]] }
#@ catch { set ::verbose_messages [list [binary format H* 74727565]] }
#@ catch { set ::test_mode_port_naming_style [list [binary format H* 746573745f6d6f64652573]] }
#@ catch { set ::write_test_input_dont_care_value [list [binary format H* 58]] }
#@ catch { set ::sdfout_top_instance_name "" }
#@ catch { set ::test_icg_n_ref_for_dft "" }
#@ catch { set ::test_sync_occ_1x_period [list [binary format H* 3230]] }
#@ catch { set ::mw_hvo_generate_macro_definition [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_allow_force_ls_with_iso_violations [list [binary format H* 74727565]] }
#@ catch { set ::compile_dont_use_dedicated_scanout [list [binary format H* 31]] }
#@ catch { set ::write_test_vhdlout [list [binary format H* 696e6c696e65]] }
#@ catch { set ::pass_dependent_file_types [list [binary format H* 706173735f637374722020757365725f6f766572726964655f636f6e73747261696e742020757365725f7265706f72745f7363726970742020757365725f636f6d70696c655f73747261746567795f7363726970742020757365725f6f766572726964655f7363726970742020706173735f636f6d70696c655f7363726970742020757365725f6275646765745f73637269707420207072655f64622020706f73745f646220207072655f6464632020706f73745f646463202073766620206d616b6566696c652020706173735f617265615f7265706f72742020706173735f74696d696e675f7265706f72742020706173735f716f725f7265706f72742020706173735f637374725f7265706f72742020706173735f6c6f672020656e7620206f632e74636c2020637374722e74636c]] }
#@ catch { set ::hdlin_enable_rtldrc_info [list [binary format H* 66616c7365]] }
#@ catch { set ::view_disable_error_windows [list [binary format H* 66616c7365]] }
#@ catch { set ::dc_allow_rtl_pg_to_signal_pins [list [binary format H* 74727565]] }
#@ catch { set ::mw_ground_port "" }
#@ catch { set ::compile_enable_constant_propagation_with_no_boundary_opt [list [binary format H* 74727565]] }
#@ catch { set ::mw_logic1_net [list [binary format H* 564444]] }
#@ catch { set ::single_group_per_sheet [list [binary format H* 66616c7365]] }
#@ catch { set ::synlib_preferred_ffs "" }
#@ catch { set ::_upf_write_21_compliant_create_power_domain [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_auto_sdp_delete [list [binary format H* 66616c7365]] }
#@ catch { set ::verilogout_inout_is_in [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_sverilog_std [list [binary format H* 32303132]] }
#@ catch { set ::gui_online_browser [list [binary format H* 66697265666f78]] }
#@ catch { set ::compile_no_new_cells_at_top_level [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdllib_tb_compare [list [binary format H* 30]] }
#@ catch { set ::test_serialize_put_fsm_clock_output [list [binary format H* 74727565]] }
#@ catch { set ::mv_allow_upf_cells_without_upf [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_command_abbrev_mode [list [binary format H* 416e797768657265]] }
#@ catch { set ::compile_adjust_max_processes_used [list [binary format H* 31]] }
#@ catch { set ::dc_shell_mode [list [binary format H* 74636c]] }
#@ catch { set ::dont_bind_unused_pins_to_logic_constant [list [binary format H* 66616c7365]] }
#@ catch { set ::bus_inference_descending_sort [list [binary format H* 74727565]] }
#@ catch { set ::gen_bussing_exact_implicit [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_sv_enforce_standalone_generate_blocks [list [binary format H* 54525545]] }
#@ catch { set ::view_cache_images [list [binary format H* 74727565]] }
#@ catch { set ::test_wrapper_chain_naming_style "" }
#@ catch { set ::gen_cell_pin_name_separator [list [binary format H* 2f]] }
#@ catch { set ::create_clock_no_input_delay [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_nor_iso_macro_allow_enable_supply_check [list [binary format H* 74727565]] }
#@ catch { set ::view_analyze_file_suffix [list [binary format H* 7620766864207668646c]] }
#@ catch { set ::hdlin_subprogram_default_values [list [binary format H* 46414c5345]] }
#@ catch { set ::bind_unused_hierarchical_pins [list [binary format H* 74727565]] }
#@ catch { set ::tcl_library [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f6c69622f74636c382e36]] }
#@ catch { set ::compile_seqmap_identify_shift_registers_with_synchronous_logic [list [binary format H* 66616c7365]] }
#@ catch { set ::sdfout_min_fall_net_delay [list [binary format H* 302e]] }
#@ catch { set ::timing_early_launch_at_borrowing_latches [list [binary format H* 74727565]] }
#@ catch { set ::mw_hvo_core_filler_cells [list [binary format H* 74727565]] }
#@ catch { set ::synopsys_exec [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f6c696e757836342f73796e2f62696e2f636f6d6d6f6e5f7368656c6c5f65786563]] }
#@ catch { set ::prev_sh_source_logging [list [binary format H* 74727565]] }
#@ catch { set ::power_cg_ignore_setup_condition [list [binary format H* 66616c7365]] }
#@ catch { set ::power_remove_redundant_clock_gates [list [binary format H* 74727565]] }
#@ catch { set ::de_enable_upf_exploration [list [binary format H* 74727565]] }
#@ catch { set ::product_version [list [binary format H* 542d323032322e30332d535031]] }
#@ catch { set ::test_disconnect_non_functional_so [list [binary format H* 31]] }
#@ catch { set ::test_default_bidir_delay [list [binary format H* 302e30]] }
#@ catch { set ::disable_delta_slew_for_tran_cstr [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_set_interface_cell_rel_sn [list [binary format H* 66616c7365]] }
#@ catch { set ::lc_run_from_legacy_library_compiler [list [binary format H* 74727565]] }
#@ catch { set ::timing_edge_specific_source_latency [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_enable_machine_monitor [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_vhdl_std [list [binary format H* 32303038]] }
#@ catch { set ::vhdlout_upcase [list [binary format H* 46414c5345]] }
#@ catch { set ::veriloglib_insert_timing_in_specify_block [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_output_onezero_for_pg [list [binary format H* 74727565]] }
#@ catch { set ::auto_attr_spread_debug [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_fix_cell_degradation [list [binary format H* 66616c7365]] }
#@ catch { set ::estimate_resource_preference [list [binary format H* 66617374]] }
#@ catch { set ::compile_register_replication_across_hierarchy [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_optimize_unloaded_seq_logic_with_no_bound_opt [list [binary format H* 66616c7365]] }
#@ catch { set ::ignore_clock_input_delay_for_skew [list [binary format H* 66616c7365]] }
#@ catch { set ::gen_show_created_busses [list [binary format H* 66616c7365]] }
#@ catch { set ::sdc_version [list [binary format H* 322e31]] }
#@ catch { set ::power_cg_reconfig_stages [list [binary format H* 66616c7365]] }
#@ catch { set ::veriloglib_tb_x_eq_dontcare [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_disable_hierarchical_inverter_opt [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_infer_local_sync_enable_only [list [binary format H* 46414c5345]] }
#@ catch { set ::systemcout_debug_mode [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_use_pdb_lib_format [list [binary format H* 66616c7365]] }
#@ catch { set ::test_user_defined_instruction_naming_style [list [binary format H* 555345522564]] }
#@ catch { set ::upf_use_additional_db_attributes [list [binary format H* 74727565]] }
#@ catch { set ::write_test_scan_check_file_naming_style [list [binary format H* 25735f7363686b2e2573]] }
#@ catch { set ::acs_makefile_name [list [binary format H* 4d616b6566696c65]] }
#@ catch { set ::rc_driver_model_mode [list [binary format H* 616476616e636564]] }
#@ catch { set ::power_cg_cell_naming_style "" }
#@ catch { set ::timing_ocvm_precedence_compatibility [list [binary format H* 66616c7365]] }
#@ catch { set ::dpcm_slewlimit [list [binary format H* 54525545]] }
#@ catch { set ::upf_allow_ls_on_dont_touch_nets [list [binary format H* 66616c7365]] }
#@ catch { set ::link_portname_allow_square_bracket_to_match_underscore [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_advanced_fix_multiple_port_nets [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hdl_expand_cell_with_no_instance [list [binary format H* 66616c7365]] }
#@ catch { set ::view_script_submenu_items [list [binary format H* 22444120746f20534745205472616e73666572222077726974655f736765]] }
#@ catch { set ::motif_files [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f61646d696e2f7365747570]] }
#@ catch { set ::compile_instance_name_suffix "" }
#@ catch { set ::upf_allow_power_gating_cell_for_retention [list [binary format H* 66616c7365]] }
#@ catch { set ::power_lib2saif_rise_fall_pd [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_use_autopartition [list [binary format H* 66616c7365]] }
#@ catch { set ::bin_path [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f6c696e757836342f73796e2f62696e]] }
#@ catch { set ::nglc_log_path [list [binary format H* 31393730305f31363539313333383336393933303539]] }
#@ catch { set ::duplicate_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_seqmap_propagate_high_effort [list [binary format H* 74727565]] }
#@ catch { set ::test_stil_multiclock_capture_procedures [list [binary format H* 66616c7365]] }
#@ catch { set ::view_watcher "" }
#@ catch { set ::sh_line_editing_mode [list [binary format H* 656d616373]] }
#@ catch { set ::timing_crpr_remove_clock_to_data_crp [list [binary format H* 66616c7365]] }
#@ catch { set ::view_set_selecting_color [list [binary format H* 7768697465]] }
#@ catch { set ::vhdlout_top_configuration_arch_name [list [binary format H* 41]] }
#@ catch { set ::verilogout_single_bit [list [binary format H* 66616c7365]] }
#@ catch { set ::test_icg_p_ref_for_dft "" }
#@ catch { set ::_acs_top_html_filename [list [binary format H* 4143535f726573756c7473]] }
#@ catch { set ::vhdlout_target_simulator "" }
#@ catch { set ::verilogout_show_unconnected_pins [list [binary format H* 46414c5345]] }
#@ catch { set ::power_enable_clock_scaling [list [binary format H* 66616c7365]] }
#@ catch { set ::current_design "" }
#@ catch { set ::timing_library_max_cap_from_lookup_table [list [binary format H* 66616c7365]] }
#@ catch { set ::bsd_physical_effort [list [binary format H* 6d656469756d]] }
#@ catch { set ::view_tools_menu_items "" }
#@ catch { set ::case_analysis_log_file "" }
#@ catch { set ::nglc_intermediate_db_files "" }
#@ catch { set ::ldd_return_val [list [binary format H* 30]] }
#@ catch { set ::mw_read_ignore_filler_cell [list [binary format H* 74727565]] }
#@ catch { set ::test_disable_enhanced_dft_drc_reporting [list [binary format H* 74727565]] }
#@ catch { set ::upf_enable_strategy_completion_during_dft_insertion [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_generate_separator_style [list [binary format H* 5f]] }
#@ catch { set ::acs_override_script_suffix [list [binary format H* 736372]] }
#@ catch { set ::hdlin_prohibit_nontri_multiple_drivers [list [binary format H* 54525545]] }
#@ catch { set ::upf_skip_retention_on_dft_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_source_uses_search_path [list [binary format H* 74727565]] }
#@ catch { set ::acs_svf_suffix [list [binary format H* 737666]] }
#@ catch { set ::test_bsd_default_strobe [list [binary format H* 39352e30]] }
#@ catch { set ::compile_enable_report_transformed_registers [list [binary format H* 66616c7365]] }
#@ catch { set ::arch [list [binary format H* 6c696e75783634]] }
#@ catch { set ::veriloglib_write_recrem_as_setuphold [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_three_state_res_func "" }
#@ catch { set ::timing_save_library_derate [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_disable_cond_default_arcs [list [binary format H* 66616c7365]] }
#@ catch { set ::test_wrp_new_power_domain_aware_dw_insertion_flow [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_no_always_on_buffer_for_redundant_isolation [list [binary format H* 66616c7365]] }
#@ catch { set ::ddc_allow_unknown_packed_commands [list [binary format H* 74727565]] }
#@ catch { set ::check_design_check_for_wire_loop [list [binary format H* 74727565]] }
#@ catch { set ::rc_receiver_model_mode [list [binary format H* 616476616e636564]] }
#@ catch { set ::sh_full_product_version [list [binary format H* 44657369676e20436f6d70696c65722047726170686963616c2056657273696f6e20542d323032322e30332d53503120666f72206c696e75783634202d204170722031342c2032303232]] }
#@ catch { set ::power_default_static_probability [list [binary format H* 302e35]] }
#@ catch { set ::generic_symbol_library [list [binary format H* 67656e657269632e736462]] }
#@ catch { set ::compile_checkpoint_phases [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_equations [list [binary format H* 46414c5345]] }
#@ catch { set ::test_bsd_control_cell_drive_limit [list [binary format H* 30]] }
#@ catch { set ::mv_use_std_cell_for_isolation [list [binary format H* 66616c7365]] }
#@ catch { set ::allow_input_delay_min_greater_than_max [list [binary format H* 66616c7365]] }
#@ catch { set ::test_connect_pse_clk_to_scan_clock_signal [list [binary format H* 74727565]] }
#@ catch { set ::upf_write_21_compliant_create_power_domain [list [binary format H* 66616c7365]] }
#@ catch { set ::test_default_scan_style [list [binary format H* 6d756c7469706c657865645f666c69705f666c6f70]] }
#@ catch { set ::lc_enable_common_shell_lc [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_allow_ls_on_leaf_pin_boundary [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_clock_gating_propagate_enable [list [binary format H* 66616c7365]] }
#@ catch { set ::find_allow_only_non_hier_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::test_validate_test_model_connectivity [list [binary format H* 66616c7365]] }
#@ catch { set ::view_report_output2file [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_seqmap_propagate_constant_clocks [list [binary format H* 66616c7365]] }
#@ catch { set ::view_read_file_suffix [list [binary format H* 6462206764622073646220656469662065716e20666e63206c7369206d6966204e455420706c612073742074646c207620766864207668646c20786e66]] }
#@ catch { set ::auto_noexec [list [binary format H* 31]] }
#@ catch { set ::hdlin_enable_elaborate_ref_linking [list [binary format H* 46414c5345]] }
#@ catch { set ::compile_inbound_max_cell_percentage [list [binary format H* 31302e30]] }
#@ catch { set ::enable_rule_based_query [list [binary format H* 66616c7365]] }
#@ catch { set ::errorCode [list [binary format H* 4e4f4e45]] }
#@ catch { set ::disable_auto_time_borrow [list [binary format H* 66616c7365]] }
#@ catch { set ::si_filter_per_aggr_noise_peak_ratio [list [binary format H* 302e3031]] }
#@ catch { set ::power_rtl_saif_file [list [binary format H* 706f7765725f72746c2e73616966]] }
#@ catch { set ::sh_tcllib_app_dirname [list [binary format H* 73796e]] }
#@ catch { set ::power_cg_derive_related_clock [list [binary format H* 66616c7365]] }
#@ catch { set ::rc_slew_lower_threshold_pct_fall [list [binary format H* 32302e303030303030]] }
#@ catch { set ::abstraction_enable_power_calculation [list [binary format H* 74727565]] }
#@ catch { set ::acs_use_default_delays [list [binary format H* 66616c7365]] }
#@ catch { set ::suppress_errors "" }
#@ catch { set ::link_library [list [binary format H* 202a20796f75725f6c6962726172792e646220]] }
#@ catch { set ::vao_feedthrough_module_name_prefix "" }
#@ catch { set ::upf_charz_enable_domain_rescoping [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_allow_ls_per_output_port [list [binary format H* 66616c7365]] }
#@ catch { set ::power_enable_datapath_gating [list [binary format H* 54525545]] }
#@ catch { set ::company "" }
#@ catch { set ::power_cg_physically_aware_cg [list [binary format H* 66616c7365]] }
#@ catch { set ::product_build_date [list [binary format H* 4170722031342c2032303232]] }
#@ catch { set ::test_default_period [list [binary format H* 3130302e30]] }
#@ catch { set ::auto_ungroup_preserve_constraints [list [binary format H* 74727565]] }
#@ catch { set ::budget_map_clock_gating_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_unconnected_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::verilogout_indirect_inout_connection [list [binary format H* 46414c5345]] }
#@ catch { set ::timing_self_loops_no_skew [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_levshi_on_constraint_only [list [binary format H* 66616c7365]] }
#@ catch { set ::estimate_io_latency [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_through_path_max_segments [list [binary format H* 35]] }
#@ catch { set ::hier_dont_trace_ungroup [list [binary format H* 30]] }
#@ catch { set ::mw_hdl_bus_dir_for_undef_cell [list [binary format H* 30]] }
#@ catch { set ::hdlin_module_name_limit [list [binary format H* 323536]] }
#@ catch { set ::vhdllib_vital_99 [list [binary format H* 66616c7365]] }
#@ catch { set ::when_analysis_permitted [list [binary format H* 74727565]] }
#@ catch { set ::vhdlout_preserve_hierarchical_types [list [binary format H* 564543544f52]] }
#@ catch { set ::synopsys_root [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c6174657374]] }
#@ catch { set ::view_arch_types [list [binary format H* 73706172634f53352068707578313020727336303030207367696d697073]] }
#@ catch { set ::auto_wire_load_selection [list [binary format H* 74727565]] }
#@ catch { set ::case_analysis_sequential_propagation [list [binary format H* 6e65766572]] }
#@ catch { set ::compile_implementation_selection [list [binary format H* 74727565]] }
#@ catch { set ::test_bsd_make_private_instructions_public [list [binary format H* 66616c7365]] }
#@ catch { set ::power_rclock_unrelated_use_fastest [list [binary format H* 74727565]] }
#@ catch { set ::enable_recovery_removal_arcs [list [binary format H* 66616c7365]] }
#@ catch { set ::test_occ_insert_clock_gating_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::test_bsd_new_output_parametrics [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_cpu_limit [list [binary format H* 302e30]] }
#@ catch { set ::compile_timing_high_effort_tns [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_hdl_verilog_define_list "" }
#@ catch { set ::view_independent_dialogs [list [binary format H* 2022746573745f7265706f72742220202020222054657374205265706f72747320222020227265706f72745f7072696e742220202022205265706f727420222020227265706f72745f6f7074696f6e73222022205265706f7274204f7074696f6e7320222020227265706f72745f77696e22202020202022205265706f7274204f757470757420222020226d616e75616c5f70616765222020202022204d616e75616c2050616765202220]] }
#@ catch { set ::upf_block_partition "" }
#@ catch { set ::mw_pgconn_cell_master "" }
#@ catch { set ::timing_enable_slack_distribution [list [binary format H* 66616c7365]] }
#@ catch { set ::write_test_vector_file_naming_style [list [binary format H* 25735f25642e2573]] }
#@ catch { set ::bus_multiple_separator_style [list [binary format H* 2c]] }
#@ catch { set ::acs_cstr_report_suffix [list [binary format H* 63737472]] }
#@ catch { set ::bsd_max_out_switching_limit [list [binary format H* 3630303030]] }
#@ catch { set ::view_report_interactive [list [binary format H* 74727565]] }
#@ catch { set ::nglc_is_none_tech_file [list [binary format H* 66616c7365]] }
#@ catch { set ::test_use_user_defined_ports_in_all_partitions [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_hdl_sverilog_define_list "" }
#@ catch { set ::test_enable_codec_sharing [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_elab_errors_deep [list [binary format H* 46414c5345]] }
#@ catch { set ::cache_file_chmod_octal [list [binary format H* 363636]] }
#@ catch { set ::view_disable_cursor_warping [list [binary format H* 74727565]] }
#@ catch { set ::upf_allow_iso_on_dont_touch_nets [list [binary format H* 74727565]] }
#@ catch { set ::test_infer_slave_clock_pulse_after_capture [list [binary format H* 696e666572]] }
#@ catch { set ::sh_auto_sdp_stack_trace_frequency [list [binary format H* 30]] }
#@ catch { set ::test_mode_port_inverted_naming_style [list [binary format H* 746573745f6d6f64655f692573]] }
#@ catch { set ::sdc_runtime_tightly_constrained_path_group_slack_percentage [list [binary format H* 3735]] }
#@ catch { set ::timing_enable_constraint_variation [list [binary format H* 66616c7365]] }
#@ catch { set ::case_analysis_propagate_through_icg [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_output_log_file "" }
#@ catch { set ::found_x11_vendor_string_apollo [list [binary format H* 30]] }
#@ catch { set ::test_avoid_control_register_of_icg_in_scan_chain_head [list [binary format H* 66616c7365]] }
#@ catch { set ::change_names_bit_blast_negative_index [list [binary format H* 66616c7365]] }
#@ catch { set ::test_default_strobe_width [list [binary format H* 302e30]] }
#@ catch { set ::compile_high_effort_area [list [binary format H* 66616c7365]] }
#@ catch { set ::disable_mdb_stop_points [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_elaborate_black_box "" }
#@ catch { set ::vhdllib_sdf_edge [list [binary format H* 66616c7365]] }
#@ catch { set ::rc_noise_model_mode [list [binary format H* 6261736963]] }
#@ catch { set ::upf_apply_retention_attribute_on_non_retention_macro [list [binary format H* 66616c7365]] }
#@ catch { set ::fsm_auto_inferring [list [binary format H* 46414c5345]] }
#@ catch { set ::test_bsdl_max_line_length [list [binary format H* 3830]] }
#@ catch { set ::compile_use_low_timing_effort [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_hvo_split_bus [list [binary format H* 66616c7365]] }
#@ catch { set ::fsm_enable_state_minimization [list [binary format H* 46414c5345]] }
#@ catch { set ::power_hdlc_do_not_split_cg_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_power_model_search_path "" }
#@ catch { set ::mw_hvo_pg_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::test_tp_enable_logic_type [list [binary format H* 67617465]] }
#@ catch { set ::hdlin_vcs_home "" }
#@ catch { set ::hdlin_mux_size_limit [list [binary format H* 3332]] }
#@ catch { set ::link_portname_allow_period_to_match_underscore [list [binary format H* 66616c7365]] }
#@ catch { set ::power_min_internal_power_threshold "" }
#@ catch { set ::query_objects_format [list [binary format H* 4c6567616379]] }
#@ catch { set ::upf_infer_complex_retention_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::test_core_wrap_use_sync_ctl_segment_length_for_fanout_check [list [binary format H* 66616c7365]] }
#@ catch { set ::xterm_executable [list [binary format H* 787465726d]] }
#@ catch { set ::mw_reference_library "" }
#@ catch { set ::hdlin_report_sequential_pruning [list [binary format H* 46414c5345]] }
#@ catch { set ::mw_hvo_dump_master_names "" }
#@ catch { set ::test_bsdl_default_suffix_name [list [binary format H* 6273646c]] }
#@ catch { set ::enable_page_mode [list [binary format H* 74727565]] }
#@ catch { set ::synthetic_library "" }
#@ catch { set ::designer "" }
#@ catch { set ::power_model_preference [list [binary format H* 6e6c706d]] }
#@ catch { set ::timing_separate_clock_gating_group [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_dft_log_print_mis_info [list [binary format H* 66616c7365]] }
#@ catch { set ::nglc_exist [list [binary format H* 74727565]] }
#@ catch { set ::read_translate_msff [list [binary format H* 54525545]] }
#@ catch { set ::_QORSUM_SCRIPTS [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f542d323032322e30332d5350312f617578782f494343322f74636c2f716f7273756d]] }
#@ catch { set ::compile_enable_physical_multibit_banking [list [binary format H* 66616c7365]] }
#@ catch { set ::view_icon_path "" }
#@ catch { set ::test_optimize_dft_ng [list [binary format H* 66616c7365]] }
#@ catch { set ::remove_constant_register [list [binary format H* 66616c7365]] }
#@ catch { set ::verilogout_equation [list [binary format H* 66616c7365]] }
#@ catch { set ::view_maximum_route_grids [list [binary format H* 30]] }
#@ catch { set ::power_sdpd_message_tolerance [list [binary format H* 302e3030303031]] }
#@ catch { set ::timing_pocvm_precedence [list [binary format H* 66696c65]] }
#@ catch { set ::view_background [list [binary format H* 626c61636b]] }
#@ catch { set ::compile_log_format [list [binary format H* 202025656c61705f74696d652025617265612025776e732025746e7320256472632025656e64706f696e74]] }
#@ catch { set ::sh_auto_sdp_crte_timeperiod [list [binary format H* 30]] }
#@ catch { set ::compile_inbound_sitedef_name "" }
#@ catch { set ::HIERARCHY_DELIMITER [list [binary format H* 2f]] }
#@ catch { set ::power_cg_ext_feedback_loop [list [binary format H* 74727565]] }
#@ catch { set ::timing_consider_internal_startpoints [list [binary format H* 74727565]] }
#@ catch { set ::upf_power_model_library "" }
#@ catch { set ::sh_command_abbrev_options [list [binary format H* 74727565]] }
#@ catch { set ::sh_user_man_path [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f542d323032322e30332d5350312f617578782f494343322f74636c2f716f7273756d2f6d616e]] }
#@ catch { set ::acs_db_suffix [list [binary format H* 6462]] }
#@ catch { set ::power_rclock_use_asynch_inputs [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_autoread_verilog_extensions [list [binary format H* 2e76]] }
#@ catch { set ::mv_skip_opcond_checking_for_unloaded_level_shifter [list [binary format H* 66616c7365]] }
#@ catch { set ::power_fix_sdpd_annotation_verbose [list [binary format H* 66616c7365]] }
#@ catch { set ::test_bsd_manufacturer_id [list [binary format H* 30]] }
#@ catch { set ::mv_allow_pg_pin_reconnection [list [binary format H* 66616c7365]] }
#@ catch { set ::nglc_result_path [list [binary format H* 2f746d70]] }
#@ catch { set ::test_enable_retiming_flops_driven_by_direct_scan_clock_driver [list [binary format H* 66616c7365]] }
#@ catch { set ::sh_enable_line_editing [list [binary format H* 74727565]] }
#@ catch { set ::target_library [list [binary format H* 796f75725f6c6962726172792e6462]] }
#@ catch { set ::test_dont_fix_constraint_violations [list [binary format H* 66616c7365]] }
#@ catch { set ::si_filter_accum_aggr_noise_peak_ratio [list [binary format H* 302e3033]] }
#@ catch { set ::sh_new_variable_message [list [binary format H* 66616c7365]] }
#@ catch { set ::write_test_formats [list [binary format H* 73796e6f7073797320747373695f61736369692074647320766572696c6f67207668646c2077676c]] }
#@ catch { set ::veriloglib_violation_notifier_name "" }
#@ catch { set ::view_use_integer_scaling [list [binary format H* 66616c7365]] }
#@ catch { set ::bus_inference_style "" }
#@ catch { set ::upf_enable_retn_map_fail_reasons [list [binary format H* 74727565]] }
#@ catch { set ::timing_dont_traverse_pg_net [list [binary format H* 74727565]] }
#@ catch { set ::power_default_toggle_rate_type [list [binary format H* 666173746573745f636c6f636b]] }
#@ catch { set ::mv_no_main_power_violations [list [binary format H* 74727565]] }
#@ catch { set ::acs_dc_exec "" }
#@ catch { set ::vhdlout_separate_scan_in [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_analyze_verbose_mode [list [binary format H* 30]] }
#@ catch { set ::view_dialogs_modal [list [binary format H* 74727565]] }
#@ catch { set ::timing_crpr_remove_muxed_clock_crp [list [binary format H* 74727565]] }
#@ catch { set ::sh_auto_sdp [list [binary format H* 66616c7365]] }
#@ catch { set ::default_input_delay [list [binary format H* 3330]] }
#@ catch { set ::upf_allow_DD_primary_with_supply_sets [list [binary format H* 66616c7365]] }
#@ catch { set ::veriloglib_zero_delay_model [list [binary format H* 66616c7365]] }
#@ catch { set ::test_use_test_models [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_remove_clock_reconvergence_pessimism [list [binary format H* 66616c7365]] }
#@ catch { set ::upf_enable_legacy_block [list [binary format H* 74727565]] }
#@ catch { set ::synlib_abort_wo_dw_license [list [binary format H* 46414c5345]] }
#@ catch { set ::hdlin_autoread_exclude_extensions "" }
#@ catch { set ::auto_path [list [binary format H* 2f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f6c69622f74636c382e36202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f736e70735f74636c202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f73796e202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f74636c6c69622f6c6962202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f6c696e757836342f73796e2f6c6962202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f73796e2f6c6962202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f677569202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f6775692f636f6d6d6f6e202f746f6f6c732f736f6674776172652f73796e6f707379732f73796e2f6c61746573742f617578782f6775692f73796e2f6c61796f7574]] }
#@ catch { set ::hdlin_legacy_naming [list [binary format H* 46414c5345]] }
#@ catch { set ::compile_seqmap_honor_sync_set_reset [list [binary format H* 66616c7365]] }
#@ catch { set ::collection_result_display_limit [list [binary format H* 313030]] }
#@ catch { set ::access_internal_pins [list [binary format H* 66616c7365]] }
#@ catch { set ::mw_enable_net_bus [list [binary format H* 66616c7365]] }
#@ catch { set ::get_attribute_float_auto_display [list [binary format H* 66616c7365]] }
#@ catch { set ::acs_insert_level_shifter [list [binary format H* 74727565]] }
#@ catch { set ::view_info_search_cmd "" }
#@ catch { set ::acs_default_pass_name [list [binary format H* 70617373]] }
#@ catch { set ::dft_enable_mis_cells_decomposition [list [binary format H* 66616c7365]] }
#@ catch { set ::enable_bit_blasted_bus_linking [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdllib_glitch_handle [list [binary format H* 74727565]] }
#@ catch { set ::mux_auto_inferring_effort [list [binary format H* 32]] }
#@ catch { set ::compile_clock_gating_through_hierarchy [list [binary format H* 66616c7365]] }
#@ catch { set ::hdlin_mux_size_min [list [binary format H* 32]] }
#@ catch { set ::sh_product_version [list [binary format H* 542d323032322e30332d535031]] }
#@ catch { set ::enable_netl_view [list [binary format H* 54525545]] }
#@ catch { set ::test_dedicated_clock_chain_clock [list [binary format H* 66616c7365]] }
#@ catch { set ::power_clock_network_include_register_clock_pin_power [list [binary format H* 54525545]] }
#@ catch { set ::sh_new_variable_message_tmp [list [binary format H* 66616c7365]] }
#@ catch { set ::test_scan_enable_inverted_port_naming_style [list [binary format H* 746573745f7365692573]] }
#@ catch { set ::rc_output_threshold_pct_fall [list [binary format H* 35302e303030303030]] }
#@ catch { set ::compile_negative_logic_methodology [list [binary format H* 66616c7365]] }
#@ catch { set ::timing_use_ceff_for_drc [list [binary format H* 66616c7365]] }
#@ catch { set ::cache_dir_chmod_octal [list [binary format H* 373737]] }
#@ catch { set ::compile_seqmap_report_non_scan_mapping [list [binary format H* 66616c7365]] }
#@ catch { set ::test_bsd_input_ac_parametrics [list [binary format H* 66616c7365]] }
#@ catch { set ::mv_make_primary_supply_available_for_always_on [list [binary format H* 74727565]] }
#@ catch { set ::uniquify_naming_style [list [binary format H* 25735f2564]] }
#@ catch { set ::compile_retime_exception_registers [list [binary format H* 66616c7365]] }
#@ catch { set ::compile_high_effort_area_in_incremental [list [binary format H* 64656661756c74]] }
#@ catch { set ::remove_unloaded_register [list [binary format H* 66616c7365]] }
#@ catch { set ::test_enable_scan_reordering_in_compile_incremental [list [binary format H* 74727565]] }
#@ catch { set ::sdc_runtime_hier_block_pins_timing_path_threshold [list [binary format H* 353030]] }
#@ catch { set ::auto_link_disable [list [binary format H* 66616c7365]] }
#@ catch { set ::write_name_nets_same_as_ports [list [binary format H* 66616c7365]] }
#@ catch { set ::vhdlout_bit_type [list [binary format H* 7374645f6c6f676963]] }
#@ catch { set ::upf_iso_map_exclude_zpr_clamp_lib_cells [list [binary format H* 66616c7365]] }
#@ catch { set ::reoptimize_design_changed_list_file_name "" }
#@ catch { set ::cache_write "" }
#@ catch { set ::link_force_case [list [binary format H* 636865636b5f7265666572656e6365]] }
#@ ##@@@## gen_common_shell_read_lib
#@ eval {read_lib sram_11_128_freepdk45_TT_1p0V_25C.lib}
#@ ##@@@##
#@ set lc_write_view_db_file false
#@ set librs [get_libs]
#@ for {set i 0} {$i < [ sizeof $librs ]} {incr i 1} {
#@   set lib [index_collection $librs $i]
#@   redirect -var a "query_object $lib" 
#@   regexp {{(")?([^"]*)(")?}} $a b c d e 
#@   write_lib $d -o $nglc_result_path/$nglc_log_path/$d.db
#@ }
#@ exit
